<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python-正则表达式' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python-正则表达式</center></div><div class='banquan'>原文出处:本文由博客园博主梦想一步登天提供。<br/>
原文连接:https://www.cnblogs.com/june-L/p/11616864.html</div><br>
    <p><span style="font-size: 18px;">正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</span></p>
<p><span style="font-size: 18px;">一、元字符</span></p>
<p><span style="font-size: 18px;">　　1) .&nbsp; &nbsp;　　--匹配任意字符（不包括换行符）</span><br /><span style="font-size: 18px;">　　2) ^&nbsp; 　　--匹配开始位置，多行模式下匹配每一行的开始</span><br /><span style="font-size: 18px;">　　3) $&nbsp; 　　--匹配结束位置，多行模式下匹配每一行的结束</span><br /><span style="font-size: 18px;">　　4) *&nbsp; 　　--匹配前一个元字符0到多次</span><br /><span style="font-size: 18px;">　　5) +&nbsp; 　　--匹配前一个元字符1到多次</span><br /><span style="font-size: 18px;">　　6) ?&nbsp; 　　--匹配前一个元字符0到1次</span><br /><span style="font-size: 18px;">　　7) {m,n}　　 --匹配前一个元字符m到n次</span><br /><span style="font-size: 18px;">　　8) \\ 　　--转义字符，跟在其后的字符将失去作为特殊元字符的含义，例如\\.只能匹配.，不能再匹配任意字符</span><br /><span style="font-size: 18px;">　　9) [] 　　--字符集，一个字符的集合，可匹配其中任意一个字符</span><br /><span style="font-size: 18px;">　　10) | 　　--逻辑表达式 或 ，比如 a|b 代表可匹配 a 或者 b</span><br /><span style="font-size: 18px;">　　11) (...) 　　--               分组，默认为捕获，即被分组的内容可以被单独取出，默认每个分组有个索引，从 1 开始，按照"("的顺序决定索引值</span><br /><span style="font-size: 18px;">　　12) (?iLmsux) 　　--           分组中可以设置模式，iLmsux之中的每个字符代表一个模式,用法参见 模式 I</span><br /><span style="font-size: 18px;">　　13) (?:...) 　　--             分组的不捕获模式，计算索引时会跳过这个分组</span><br /><span style="font-size: 18px;">　　14) (?P&lt;name&gt;...) 　　--       分组的命名模式，取此分组中的内容时可以使用索引也可以使用name</span><br /><span style="font-size: 18px;">　　15) (?P=name) 　　--           分组的引用模式，可在同一个正则表达式用引用前面命名过的正则</span><br /><span style="font-size: 18px;">　　16) (?#...) 　　--             注释，不影响正则表达式其它部分,用法参见 模式 I</span><br /><span style="font-size: 18px;">　　17) (?=...) 　　--             顺序肯定环视，表示所在位置右侧能够匹配括号内正则</span><br /><span style="font-size: 18px;">　　18 (?!...) 　　--             顺序否定环视，表示所在位置右侧不能匹配括号内正则</span><br /><span style="font-size: 18px;">　　19) (?&lt;=...) 　　--            逆序肯定环视，表示所在位置左侧能够匹配括号内正则</span><br /><span style="font-size: 18px;">　　20) (?&lt;!...) 　　--逆序否定环视，表示所在位置左侧不能匹配括号内正则</span><br /><span style="font-size: 18px;">　　21) (?(id/name)yes|no) 　　--  若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则</span><br /><span style="font-size: 18px;">　　22) \number 　　--             匹配和前面索引为number的分组捕获到的内容一样的字符串</span><br /><span style="font-size: 18px;">　　23) \A 　　--                  匹配字符串开始位置，忽略多行模式</span><br /><span style="font-size: 18px;">　　24) \Z 　　--                  匹配字符串结束位置，忽略多行模式</span><br /><span style="font-size: 18px;">　　25) \b 　　--                  匹配位于单词开始或结束位置的空字符串</span><br /><span style="font-size: 18px;">　　26) \B 　　--                  匹配不位于单词开始或结束位置的空字符串</span><br /><span style="font-size: 18px;">　　27) \d 　　--                  匹配一个数字， 相当于 [0-9]</span><br /><span style="font-size: 18px;">　　28) \D 　　--                  匹配非数字,相当于 [^0-9]</span><br /><span style="font-size: 18px;">　　29) \s 　　--                  匹配任意空白字符， 相当于 [ \t\n\r\f\v]</span><br /><span style="font-size: 18px;">　　30) \S 　　--                  匹配非空白字符，相当于 [^ \t\n\r\f\v]</span><br /><span style="font-size: 18px;">　　31) \w 　　--&nbsp;匹配数字、字母、下划线中任意一个字符， 相当于 [a-zA-Z0-9_]</span><br /><span style="font-size: 18px;">　　32) \W 　　--                  匹配非数字、字母、下划线中的任意字符，相当于 [^a-zA-Z0-9_]</span></p>
<p><br /><span style="font-size: 18px;">二、函数 （参见 python 模块 re 文档）</span><br /><span style="font-size: 18px;">　　2.1   compile(pattern, flags=0)   </span><br /><span style="font-size: 18px;">　　　　给定一个正则表达式 pattern，指定使用的模式 flags 默认为0 即不使用任何模式,然后会返回一个 SRE_Pattern </span><br /><span style="font-size: 18px;">　　示例：</span><br /><span style="font-size: 18px;">　　　　regex = re.compile(".+")</span><br /><span style="font-size: 18px;">　　　　print regex</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; &lt;_sre.SRE_Pattern object at 0x00000000026BB0B8&gt;</span></p>
<p><span style="font-size: 18px;">　　这个对象可以调用其他函数来完成匹配，一般来说推荐使用 compile 函数预编译出一个正则模式之后再去使用，这样在后面的代码中可以很方便的复用它，当然大部分函数也可以不用 compile 直接使用，具体见 findall 函数</span></p>
<p><span style="font-size: 18px;">　　示例：</span><br /><span style="font-size: 18px;">　　　　s = '''first line</span><br /><span style="font-size: 18px;">　　　　second line</span><br /><span style="font-size: 18px;">　　　　third line'''</span><br /><br /><span style="font-size: 18px;">　　　　# 调用 findall 函数</span><br /><span style="font-size: 18px;">　　　　print regex.findall(s)</span><br /><span style="font-size: 18px;">　　　　#&gt;&gt;&gt; ['first line', 'second line', 'third line']</span><br /><span style="font-size: 18px;">　　　　# 调用 search 函数</span><br /><span style="font-size: 18px;">　　　　print regex.search(s).group()</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; first lin</span></p>
<p><span style="font-size: 18px;">　　2.2  escape(pattern)   </span><br /><span style="font-size: 18px;">　　　　转义 如果你需要操作的文本中含有正则的元字符，你在写正则的时候需要将元字符加上反斜扛 \ 去匹配自身， 而当这样的字符很多时，写出来的正则表达式就看起来很乱而且写起来也挺麻烦的，这个时候你可以使用这个函数,用法如下</span></p>
<p><span style="font-size: 18px;">　　示例：</span><br /><span style="font-size: 18px;">　　　　s = ".+\d123"</span><br /><span style="font-size: 18px;">　　　　regex_str = re.escape(".+\d123")</span><br /><span style="font-size: 18px;">　　　　# 查看转义后的字符</span><br /><span style="font-size: 18px;">　　　　print regex_str</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; \.\+\\d123</span></p>
<p><span style="font-size: 18px;">　　　　# 查看匹配到的结果</span><br /><span style="font-size: 18px;">　　　　for g in re.findall(regex_str, s):</span><br /><span style="font-size: 18px;">    　　　　print g</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; .+\d123</span></p>
<p><br /><span style="font-size: 18px;">　　2.3  findall(pattern, string, flags=0)   </span><br /><span style="font-size: 18px;">　　　　参数 pattern 为正则表达式, string 为待操作字符串, flags 为所用模式，函数作用为在待操作字符串中寻找所有匹配正则表达式的字串，返回一个列表，如果没有匹配到任何子串，返回一个空列表。</span></p>
<p><span style="font-size: 18px;">　　示例：</span><br /><span style="font-size: 18px;">　　　　s = '''first line</span><br /><span style="font-size: 18px;">　　　　second line</span><br /><span style="font-size: 18px;">　　　　third line'''</span></p>
<p><span style="font-size: 18px;">　　　　# compile 预编译后使用 findall</span><br /><span style="font-size: 18px;">　　　　regex = re.compile("\w+")</span><br /><span style="font-size: 18px;">　　　　print regex.findall(s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; ['first', 'line', 'second', 'line', 'third', 'line']</span></p>
<p><span style="font-size: 18px;">　　　　# 不使用 compile 直接使用 findall</span><br /><span style="font-size: 18px;">　　　　print re.findall("\w+", s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; ['first', 'line', 'second', 'line', 'third', 'line']</span></p>
<p><span style="font-size: 18px;">&nbsp;</span></p>
<p><span style="font-size: 18px;">　　2.4 finditer(pattern, string, flags=0)   </span><br /><span style="font-size: 18px;">　　　　参数和作用与 findall 一样，不同之处在于 findall 返回一个列表， finditer 返回一个迭代器， 而且迭代器每次返回的值并不是字符串，而是一个 SRE_Match (参见 第四小节 re 内置对象用法) 对象，这个对象的具体用法见 match 函数。</span></p>
<p><span style="font-size: 18px;">　　　示例：</span><br /><span style="font-size: 18px;">　　　　s = '''first line</span><br /><span style="font-size: 18px;">　　　　second line</span><br /><span style="font-size: 18px;">　　　　third line'''</span></p>
<p><span style="font-size: 18px;">　　　　regex = re.compile("\w+")</span><br /><span style="font-size: 18px;">　　　　print regex.finditer(s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; &lt;callable-iterator object at 0x0000000001DF3B38&gt;</span><br /><span style="font-size: 18px;">　　　　for i in regex.finditer(s):</span><br /><span style="font-size: 18px;">    　　　　print i</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; &lt;_sre.SRE_Match object at 0x0000000002B7A920&gt;</span><br /><span style="font-size: 18px;">　　　　#         &lt;_sre.SRE_Match object at 0x0000000002B7A8B8&gt;</span><br /><span style="font-size: 18px;">　　　　#         &lt;_sre.SRE_Match object at 0x0000000002B7A920&gt;</span><br /><span style="font-size: 18px;">　　　　#         &lt;_sre.SRE_Match object at 0x0000000002B7A8B8&gt;</span><br /><span style="font-size: 18px;">　　　　#         &lt;_sre.SRE_Match object at 0x0000000002B7A920&gt;</span><br /><span style="font-size: 18px;">　　　　#         &lt;_sre.SRE_Match object at 0x0000000002B7A8B8&gt;</span></p>
<p><br /><span style="font-size: 18px;">　　2.5  match(pattern, string, flags=0) </span></p>
<p><span style="font-size: 18px;">　　　　###从头匹配  </span><br /><span style="font-size: 18px;">　　　　使用指定正则去待操作字符串中寻找可以匹配的子串, 返回匹配上的第一个字串，并且不再继续找，需要注意的是 match 函数是从字符串开始处开始查找的，如果开始处不匹配，则不再继续寻找，返回值为 一个 SRE_Match 对象，找不到时返回 None</span></p>
<p><span style="font-size: 18px;">　　示例：</span><br /><span style="font-size: 18px;">　　　　s = '''first line</span><br /><span style="font-size: 18px;">　　　　second line</span><br /><span style="font-size: 18px;">　　　　third line'''</span></p>
<p><span style="font-size: 18px;">　　　　# compile</span><br /><span style="font-size: 18px;">　　　　regex = re.compile("\w+")</span><br /><span style="font-size: 18px;">　　　　m = regex.match(s)</span><br /><span style="font-size: 18px;">　　　　print m</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; &lt;_sre.SRE_Match object at 0x0000000002BCA8B8&gt;</span><br /><span style="font-size: 18px;">　　　　print m.group()</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; first</span></p>
<p><span style="font-size: 18px;">　　　　# s 的开头是 "f", 但正则中限制了开始为 i 所以找不到</span><br /><span style="font-size: 18px;">　　　　regex = re.compile("^i\w+")</span><br /><span style="font-size: 18px;">　　　　print regex.match(s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; None</span></p>
<p>&nbsp;</p>
<p>　　<span style="font-size: 18px;">正则表达式之match以及分组</span></p>
<p><span style="font-size: 18px;">　　　　无分组示例：</span></p>
<p><span style="font-size: 18px;">　　　　#为何要有分组？</span><br /><span style="font-size: 18px;">	　　　　提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e95e33d5-e0d8-4140-9e51-5c9eebb08b35')"><img id="code_img_closed_e95e33d5-e0d8-4140-9e51-5c9eebb08b35" class="code_img_closed" src="./images/python-正则表达式0.png" alt="" /><img id="code_img_opened_e95e33d5-e0d8-4140-9e51-5c9eebb08b35" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e95e33d5-e0d8-4140-9e51-5c9eebb08b35',event)" src="./images/python-正则表达式1.png" alt="" />
<div id="cnblogs_code_open_e95e33d5-e0d8-4140-9e51-5c9eebb08b35" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">1</span>     <span style="color: #0000ff;">import</span><span style="color: #000000;"> re
</span><span style="color: #008080;">2</span>     
<span style="color: #008080;">3</span>     origin = <span style="color: #800000;">"</span><span style="color: #800000;">hello hhajoijiowrd dha khjhs 19ah</span><span style="color: #800000;">"</span>
<span style="color: #008080;">4</span>     r = re.match(<span style="color: #800000;">"</span><span style="color: #800000;">h\w+</span><span style="color: #800000;">"</span><span style="color: #000000;">, origin)
</span><span style="color: #008080;">5</span>     <span style="color: #0000ff;">print</span>(r.group())   <span style="color: #008000;">#</span><span style="color: #008000;">获取匹配到的所有结果</span>
<span style="color: #008080;">6</span>     <span style="color: #0000ff;">print</span>(r.groups())  <span style="color: #008000;">#</span><span style="color: #008000;">获取模型中匹配到的分组结果</span>
<span style="color: #008080;">7</span>     <span style="color: #0000ff;">print</span>(r.groupdict())   <span style="color: #008000;">#</span><span style="color: #008000;">获取模型中匹配到的分组中所有执行了key的组</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="font-size: 18px;">　　结果图示：</span></p>
<p><img src="./images/python-正则表达式2.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;">　　有分组示例：</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3d7f1b98-e4b0-46a0-bcef-9c1485d63c33')"><img id="code_img_closed_3d7f1b98-e4b0-46a0-bcef-9c1485d63c33" class="code_img_closed" src="./images/python-正则表达式0.png" alt="" /><img id="code_img_opened_3d7f1b98-e4b0-46a0-bcef-9c1485d63c33" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3d7f1b98-e4b0-46a0-bcef-9c1485d63c33',event)" src="./images/python-正则表达式1.png" alt="" />
<div id="cnblogs_code_open_3d7f1b98-e4b0-46a0-bcef-9c1485d63c33" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">1</span>     <span style="color: #0000ff;">import</span><span style="color: #000000;"> re
</span><span style="color: #008080;">2</span>     
<span style="color: #008080;">3</span>     origin = <span style="color: #800000;">"</span><span style="color: #800000;">hello hhajoijiowrd dha khjhs 19ah</span><span style="color: #800000;">"</span>
<span style="color: #008080;">4</span>     r = re.match(<span style="color: #800000;">"</span><span style="color: #800000;">h(\w+)</span><span style="color: #800000;">"</span><span style="color: #000000;">, origin)
</span><span style="color: #008080;">5</span>     r = re.match(<span style="color: #800000;">"</span><span style="color: #800000;">(?P&lt;n1&gt;h)(?P&lt;n2&gt;\w+)</span><span style="color: #800000;">"</span>, origin)  <span style="color: #008000;">#</span><span style="color: #008000;">通过?P&lt;name&gt;将模型中匹配到的分组回到groupdict()字典中</span>
<span style="color: #008080;">6</span>     <span style="color: #0000ff;">print</span>(r.group())   <span style="color: #008000;">#</span><span style="color: #008000;">获取匹配到的所有结果</span>
<span style="color: #008080;">7</span>     <span style="color: #0000ff;">print</span>(r.groups())  <span style="color: #008000;">#</span><span style="color: #008000;">获取模型中匹配到的分组结果</span>
<span style="color: #008080;">8</span>     <span style="color: #0000ff;">print</span>(r.groupdict())   <span style="color: #008000;">#</span><span style="color: #008000;">获取模型中匹配到的分组中所有执行了key的组</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>　　<span style="font-size: 18px;">结果图示：</span></p>
<p><img src="./images/python-正则表达式5.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;">&nbsp;　　</span><span style="font-size: 18px;">2.6 purge()&nbsp;</span></p>
<p><span style="font-size: 18px;">　　　　当你在程序中使用 re 模块，无论是先使用 compile 还是直接使用比如 findall 来使用正则表达式操作文本，re 模块都会将正则表达式先编译一下， 并且会将编译过后的正则表达式放到缓存中，这样下次使用同样的正则表达式的时候就不需要再次编译， 因为编译其实是很费时的，这样可以提升效率，而默认缓存的正则表达式的个数是 100, 当你需要频繁使用少量正则表达式的时候，缓存可以提升效率，而使用的正则表达式过多时，缓存带来的优势就不明显了， 这个函数的作用是清除缓存中的正则表达式，可能在你需要优化占用内存的时候会用到。</span></p>
<p><span style="font-size: 18px;">　　2.7 search(pattern, string, flags=0) </span></p>
<p><span style="font-size: 18px;">　　　　###浏览全部字符串，匹配第一个符合规则的字符串。 </span><br /><span style="font-size: 18px;">　　　函数类似于 match，不同之处在于不限制正则表达式的开始匹配位置</span></p>
<p><span style="font-size: 18px;">　　示例：</span><br /><span style="font-size: 18px;">　　　　s = '''first line</span><br /><span style="font-size: 18px;">　　　　second line</span><br /><span style="font-size: 18px;">　　　　third line'''</span></p>
<p><span style="font-size: 18px;">　　　　# 需要从开始处匹配 所以匹配不到 </span><br /><span style="font-size: 18px;">　　　　print re.match('i\w+', s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; None</span></p>
<p><span style="font-size: 18px;">　　　　# 没有限制起始匹配位置</span><br /><span style="font-size: 18px;">　　　　print re.search('i\w+', s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; &lt;_sre.SRE_Match object at 0x0000000002C6A920&gt;</span></p>
<p><span style="font-size: 18px;">　　　　print re.search('i\w+', s).group()</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; irst</span></p>
<p><span style="font-size: 18px;">　</span></p>
<p>　　　　<span style="font-size: 18px;">正则表达式之search以及分组</span></p>
<p><span style="font-size: 18px;">　　　　　　无分组示例：</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('0285eddb-a71b-44e4-bc12-2d2f8da31ef3')"><img id="code_img_closed_0285eddb-a71b-44e4-bc12-2d2f8da31ef3" class="code_img_closed" src="./images/python-正则表达式0.png" alt="" /><img id="code_img_opened_0285eddb-a71b-44e4-bc12-2d2f8da31ef3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0285eddb-a71b-44e4-bc12-2d2f8da31ef3',event)" src="./images/python-正则表达式1.png" alt="" />
<div id="cnblogs_code_open_0285eddb-a71b-44e4-bc12-2d2f8da31ef3" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">1</span>     <span style="color: #0000ff;">import</span><span style="color: #000000;"> re
</span><span style="color: #008080;">2</span>     
<span style="color: #008080;">3</span>     origin = <span style="color: #800000;">"</span><span style="color: #800000;">hello hhajoijiowrd dha khjhs 19</span><span style="color: #800000;">"</span>
<span style="color: #008080;">4</span>     r = re.search(<span style="color: #800000;">"</span><span style="color: #800000;">a\w+</span><span style="color: #800000;">"</span><span style="color: #000000;">, origin)
</span><span style="color: #008080;">5</span>     <span style="color: #0000ff;">print</span>(r.group())   <span style="color: #008000;">#</span><span style="color: #008000;">获取匹配到的所有结果</span>
<span style="color: #008080;">6</span>     <span style="color: #0000ff;">print</span>(r.groups())  <span style="color: #008000;">#</span><span style="color: #008000;">获取模型中匹配到的分组结果</span>
<span style="color: #008080;">7</span>     <span style="color: #0000ff;">print</span>(r.groupdict())   <span style="color: #008000;">#</span><span style="color: #008000;">获取模型中匹配到的分组中所有执行了key的组</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="font-size: 18px;">　　　　结果图示：</span></p>
<p><span style="font-size: 18px;"><img src="./images/python-正则表达式8.png" alt="" /></span></p>
<p><span style="font-size: 18px;">　　　　有分组示例：</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('292fc60f-f2c5-4062-8cab-026430d91118')"><img id="code_img_closed_292fc60f-f2c5-4062-8cab-026430d91118" class="code_img_closed" src="./images/python-正则表达式0.png" alt="" /><img id="code_img_opened_292fc60f-f2c5-4062-8cab-026430d91118" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('292fc60f-f2c5-4062-8cab-026430d91118',event)" src="./images/python-正则表达式1.png" alt="" />
<div id="cnblogs_code_open_292fc60f-f2c5-4062-8cab-026430d91118" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">1</span>     <span style="color: #0000ff;">import</span><span style="color: #000000;"> re
</span><span style="color: #008080;">2</span>     
<span style="color: #008080;">3</span>     origin = <span style="color: #800000;">"</span><span style="color: #800000;">hello hhajoijiowrd dha khjhs 19</span><span style="color: #800000;">"</span>
<span style="color: #008080;">4</span>     r = re.search(<span style="color: #800000;">"</span><span style="color: #800000;">a(\w+).*(?P&lt;dict&gt;\d)$</span><span style="color: #800000;">"</span>, origin)  <span style="color: #008000;">#</span><span style="color: #008000;">通过?P&lt;name&gt;将模型中匹配到的分组回到groupdict()字典中</span>
<span style="color: #008080;">5</span>     <span style="color: #0000ff;">print</span>(r.group())   <span style="color: #008000;">#</span><span style="color: #008000;">获取匹配到的所有结果</span>
<span style="color: #008080;">6</span>     <span style="color: #0000ff;">print</span>(r.groups())  <span style="color: #008000;">#</span><span style="color: #008000;">获取模型中匹配到的分组结果</span>
<span style="color: #008080;">7</span>     <span style="color: #0000ff;">print</span>(r.groupdict())   <span style="color: #008000;">#</span><span style="color: #008000;">获取模型中匹配到的分组中所有执行了key的组    </span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>　　　　<span style="font-size: 18px;">结果图示：</span></p>
<p><span style="font-size: 18px;"><img src="./images/python-正则表达式11.png" alt="" /></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;">　　2.8 split(pattern, string, maxsplit=0, flags=0) </span><br /><span style="font-size: 18px;">　　　　参数 maxsplit 指定切分次数， 函数使用给定正则表达式寻找切分字符串位置，返回包含切分后子串的列表，如果匹配不到，则返回包含原字符串的一个列表</span></p>
<p><span style="font-size: 18px;">　　　　示例：</span><br /><span style="font-size: 18px;">　　　　s = '''first 111 line</span><br /><span style="font-size: 18px;">　　　　second 222 line</span><br /><span style="font-size: 18px;">　　　　third 333 line'''</span></p>
<p><span style="font-size: 18px;">　　　　# 按照数字切分</span><br /><span style="font-size: 18px;">　　　　print re.split('\d+', s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; ['first ', ' line\nsecond ', ' line\nthird ', ' line']</span></p>
<p><span style="font-size: 18px;">　　　　# \.+ 匹配不到 返回包含自身的列表</span><br /><span style="font-size: 18px;">　　　　print re.split('\.+', s, 1)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; ['first 111 line\nsecond 222 line\nthird 333 line']</span></p>
<p><span style="font-size: 18px;">　　　　# maxsplit 参数</span><br /><span style="font-size: 18px;">　　　　print re.split('\d+', s, 1)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; ['first ', ' line\nsecond 222 line\nthird 333 line']</span></p>
<p><span style="font-size: 18px;">　　2.9  sub(pattern, repl, string, count=0, flags=0)   </span><br /><span style="font-size: 18px;">　　　　替换函数，将正则表达式 pattern 匹配到的字符串替换为 repl 指定的字符串,  参数 count 用于指定最大替换次数</span></p>
<p><span style="font-size: 18px;">　　示例：</span><br /><span style="font-size: 18px;">　　　　s = "the sum of 7 and 9 is [7+9]."</span></p>
<p><span style="font-size: 18px;">　　　　# 基本用法 将目标替换为固定字符串</span><br /><span style="font-size: 18px;">　　　　print re.sub('\[7\+9\]', '16', s)</span><br /><span style="font-size: 18px;">　　　　#&nbsp;&gt;&gt;&gt; the sum of 7 and 9 is 16.</span></p>
<p><span style="font-size: 18px;">　　　　# 高级用法 1 使用前面匹配的到的内容 \1 代表 pattern 中捕获到的第一个分组的内容</span><br /><span style="font-size: 18px;">　　　　print re.sub('\[(7)\+(9)\]', r'\2\1', s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; the sum of 7 and 9 is 97.</span></p>
<p><span style="font-size: 18px;">　　　　# 高级用法 2 使用函数型 repl 参数, 处理匹配到的 SRE_Match 对象</span><br /><span style="font-size: 18px;">　　　　def replacement(m):</span><br /><span style="font-size: 18px;">    　　　　　　p_str = m.group()</span><br /><span style="font-size: 18px;">    　　　　　　if p_str == '7':</span><br /><span style="font-size: 18px;">        　　　　　　　　return '77'</span><br /><span style="font-size: 18px;">    　　　　　　if p_str == '9':</span><br /><span style="font-size: 18px;">        　　　　　　　　return '99'</span><br /><span style="font-size: 18px;">    　　　　return ' '</span><br /><span style="font-size: 18px;">　　　　print re.sub('\d', replacement, s)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; the sum of 77 and 99 is [77+99].</span></p>
<p><span style="font-size: 18px;">　　　　# 高级用法 3 使用函数型 repl 参数, 处理匹配到的 SRE_Match 对象 增加作用域 自动计算</span><br /><span style="font-size: 18px;">　　　　scope = {}</span><br /><span style="font-size: 18px;">　　　　example_string_1 = "the sum of 7 and 9 is [7+9]."</span><br /><span style="font-size: 18px;">　　　　example_string_2 = "[name = 'Mr.Gumby']Hello,[name]"</span></p>
<p><span style="font-size: 18px;">　　　　def replacement(m):</span><br /><span style="font-size: 18px;">    　　　　　　code = m.group(1)</span><br /><span style="font-size: 18px;">    　　　　　　st = ''</span><br /><span style="font-size: 18px;">    　　　　　　try:</span><br /><span style="font-size: 18px;">        　　　　　　　　st = str(eval(code, scope))</span><br /><span style="font-size: 18px;">    　　　　　　except SyntaxError:</span><br /><span style="font-size: 18px;">        　　　　　　　　exec code in scope</span><br /><span style="font-size: 18px;">    　　　　　　return st</span></p>
<p><span style="font-size: 18px;">　　　　# 解析: code='7+9'</span><br /><span style="font-size: 18px;">　　　　#       str(eval(code, scope))='16'</span><br /><span style="font-size: 18px;">　　　　print re.sub('\[(.+?)\]', replacement, example_string_1)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; the sum of 7 and 9 is 16.</span></p>
<p><br /><span style="font-size: 18px;">　　　　# 两次替换</span><br /><span style="font-size: 18px;">　　　　# 解析1: code="name = 'Mr.Gumby'"</span><br /><span style="font-size: 18px;">　　　　#       eval(code)</span><br /><span style="font-size: 18px;">　　　　#       raise SyntaxError</span><br /><span style="font-size: 18px;">　　　　#       exec code in scope</span><br /><span style="font-size: 18px;">　　　　#       在命名空间 scope 中将 "Mr.Gumby" 赋给了变量 name</span></p>
<p><span style="font-size: 18px;">　　　　# 解析2: code="name"</span><br /><span style="font-size: 18px;">　　　　#       eval(name) 返回变量 name 的值 Mr.Gumby</span><br /><span style="font-size: 18px;">　　　　print re.sub('\[(.+?)\]', replacement, example_string_2)</span><br /><span style="font-size: 18px;">　　　　# &gt;&gt;&gt; Hello,Mr.Gumby</span><em id="__mceDel"><span style="font-size: 18px;">&nbsp;</span></em></p>
<p><span style="font-size: 18px;">　　2.10  subn(pattern, repl, string, count=0, flags=0)   </span><br /><span style="font-size: 18px;">　　　作用与函数 sub 一样， 唯一不同之处在于返回值为一个元组，第一个值为替换后的字符串，第二个值为发生替换的次数</span></p>
<p><span style="font-size: 18px;">　　2.11  template(pattern, flags=0)   </span></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>