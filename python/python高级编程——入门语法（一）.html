<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python高级编程——入门语法（一）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python高级编程——入门语法（一）</center></div><div class='banquan'>原文出处:本文由博客园博主呱唧_T_呱唧提供。<br/>
原文连接:https://www.cnblogs.com/aitiknowledge/p/11447781.html</div><br>
    <h2>元类</h2>
<p>　　在python中一切皆对象，类也是对象，只不过类是一个创建对象的对象，我们可以在类中动态的创建一个类，比如</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">def</span><span style="color: #000000;"> func(name):
    </span><span style="color: #0000ff;">if</span> name == <span style="color: #800000;">"</span><span style="color: #800000;">Plane</span><span style="color: #800000;">"</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Plane(object):
            </span><span style="color: #0000ff;">pass</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> Plane
     </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Metrorolite(object):
            </span><span style="color: #0000ff;">pass</span>
        <span style="color: #0000ff;">return</span> Mrtroolite</pre>
</div>
<p>　　虽然根据上述代码可以动态创建一个类，但是整个类的代码仍需要我们编写的</p>
<p>　　type()有两种作用：</p>
<p>　　　　1、检查对象类型</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> People(object):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, id, name, employees):
        self.id </span>=<span style="color: #000000;"> id
        self.name </span>=<span style="color: #000000;"> name
    
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> func(self):
        </span><span style="color: #0000ff;">return</span>

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">"</span><span style="color: #800000;">__main__</span><span style="color: #800000;">"</span><span style="color: #000000;">:
    id </span>= 1001<span style="color: #000000;">
    name </span>= <span style="color: #800000;">"</span><span style="color: #800000;">abc</span><span style="color: #800000;">"</span><span style="color: #000000;">
    employees </span>= [1,2,3<span style="color: #000000;">]
    people </span>=<span style="color: #000000;"> People(id, name, employees)
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 检查整型</span>
    <span style="color: #0000ff;">print</span>(type(id))   <span style="color: #008000;">#</span><span style="color: #008000;"> &lt;class 'int'&gt;</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 检查字符串型</span>
    <span style="color: #0000ff;">print</span>(type(name))   <span style="color: #008000;">#</span><span style="color: #008000;"> &lt;class 'str'&gt;</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 检查列表型</span>
    <span style="color: #0000ff;">print</span>(type(employees))  <span style="color: #008000;">#</span><span style="color: #008000;"> &lt;class 'list'&gt;</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 检查类的对象型</span>
    <span style="color: #0000ff;">print</span>(type(people))    <span style="color: #008000;">#</span><span style="color: #008000;">  &lt;class '__main__.People'&gt;</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 检查类类型</span>
    <span style="color: #0000ff;">print</span>(type(People))    <span style="color: #008000;">#</span><span style="color: #008000;"> &lt;class 'type'&gt;</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 检查函数型</span>
    <span style="color: #0000ff;">print</span>(type(people.func))   <span style="color: #008000;">#</span><span style="color: #008000;">   &lt;class 'method'&gt;</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> 如果我们对其结果再次type()得到的结果都是type类型，这就验证了一切解释对象</span></pre>
</div>
<p>　　2、还有一个高大上的作用就是动态的创建类</p>
<p>　　　　　　语法：type(类名, 由父类名称组成的元组（可以为空）, 包含属性的字典（名称和值）)</p>
<p>　　　　　　返回值是一个类</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 空类</span>
Chinese = type(<span style="color: #800000;">"</span><span style="color: #800000;">People</span><span style="color: #800000;">"</span><span style="color: #000000;">, (), {})

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 继承父类，父类以元组的形式表达</span>
Chinses = type(<span style="color: #800000;">"</span><span style="color: #800000;">People</span><span style="color: #800000;">"</span><span style="color: #000000;">, (object, ), {})

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 给类一些属性(下述都是类属性）和方法（方法可以自定义，依次是实例方法、类方法、静态方法）</span>

<span style="color: #0000ff;">def</span><span style="color: #000000;"> sayHI(self):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">HI</span><span style="color: #800000;">"</span><span style="color: #000000;">)

@classmethod
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> sayHello(cls):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Hello</span><span style="color: #800000;">"</span><span style="color: #000000;">)

@staticmethod
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> sayBye():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">Bye</span><span style="color: #800000;">"</span><span style="color: #000000;">)

Chinese </span>= type(<span style="color: #800000;">"</span><span style="color: #800000;">People</span><span style="color: #800000;">"</span>, (object, ), {<span style="color: #800000;">"</span><span style="color: #800000;">id</span><span style="color: #800000;">"</span>: 1001, <span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">zhangsan</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">func1</span><span style="color: #800000;">"</span>: sayHI, <span style="color: #800000;">"</span><span style="color: #800000;">func2</span><span style="color: #800000;">"</span>: sayHello, <span style="color: #800000;">"</span><span style="color: #800000;">func3</span><span style="color: #800000;">"</span><span style="color: #000000;">: sayBye})

</span><span style="color: #008000;">#</span><span style="color: #008000;"> Chinese 不是类名，People是类名，Chinese是一个引用变量</span></pre>
</div>
<p>　　元类的定义：</p>
<p>　　　　元类就是用来创建类的&ldquo;东西&rdquo;&nbsp;</p>
<p>　　　　元类是类的类， 是类的模板</p>
<p>　　　　元类是用来控制如何创建类的， 正如类是创建对象的模板一样，<span style="color: #ff0000;">而元类的主要目的是为了控制类的创建行为&nbsp;</span></p>
<p>　　　　元类的实例化结果是我们用class定义的类，正如类的实例为对象&nbsp;</p>
<p>　　　　type是python的一个内建元类， 用来直接控制生成类&nbsp;</p>
<p>　　　　python中任何class定义的类其实都是type类实例化的对象&nbsp;</p>
<p>　　　　当然了，你也可以创建自己的元类，需要继承 type。</p>
<p>　　元类的定义和使用：</p>
<p>　　　　通过函数返回一个元类：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 自定义函数</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> summary(a, b):
    </span><span style="color: #0000ff;">return</span> a+<span style="color: #000000;">b


</span><span style="color: #008000;">#</span><span style="color: #008000;"> 这个函数的作用是修改当前类的属性的值和方法的功能，并且返回一个类</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> upper_attr(future_class_name, future_class_parent, future_class_attr):

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 可以修改当前类定义的属性的值和方法的功能</span>
    newAttr =<span style="color: #000000;"> {}
    </span><span style="color: #0000ff;">for</span> name, value <span style="color: #0000ff;">in</span><span style="color: #000000;"> future_class_attr.items():
        </span><span style="color: #0000ff;">if</span> name == <span style="color: #800000;">"</span><span style="color: #800000;">bar</span><span style="color: #800000;">"</span><span style="color: #000000;">:
            newAttr[name] </span>= <span style="color: #800000;">"</span><span style="color: #800000;">变量值修改了</span><span style="color: #800000;">"</span>
        <span style="color: #0000ff;">if</span> name == <span style="color: #800000;">"</span><span style="color: #800000;">func</span><span style="color: #800000;">"</span><span style="color: #000000;">:
            newAttr[name] </span>=<span style="color: #000000;"> summary

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> type(future_class_name, future_class_parent, newAttr)


</span><span style="color: #0000ff;">class</span> Operation(object, metaclass=<span style="color: #000000;">upper_attr):
    bar </span>= <span style="color: #800000;">"</span><span style="color: #800000;">修改之前的值</span><span style="color: #800000;">"</span><span style="color: #000000;">
    func </span>=<span style="color: #000000;"> None


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">"</span><span style="color: #800000;">__main__</span><span style="color: #800000;">"</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">print</span>(Operation.bar)    <span style="color: #008000;">#</span><span style="color: #008000;"> 变量值修改了</span>
    <span style="color: #0000ff;">print</span>(Operation.func(2, 4))    <span style="color: #008000;">#</span><span style="color: #008000;"> 返回值6</span></pre>
</div>
<p>　　　　通过继承type生成元类（博主也没有看懂，了解即可，用到极少）：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Meta(type):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span>(cls, *args, **<span style="color: #000000;">kwargs):
        super().</span><span style="color: #800080;">__init__</span>(*<span style="color: #000000;">args)

    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__new__</span>(cls, *args, **kwargs):<br />　　　　name, bases, attrs = args<br />　　　　return super().__new__(cls, name, bases, attrs)<br />class M_Class(metaclass=Meta):<br />　　def __new__(cls, *args, **kwargs):<br />　　　　return super().__new__(cls)<br />　　def __init__(self):<br />　　　　pass</pre>
</div>
<p>&nbsp;</p>
<h2>动态语言</h2>
<p>　　静态语言和动态语言的区别：</p>
<p style="margin-left: 60px;">静态语言（强类型语言）<br />　　静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要 求在使用变量之前必须声明数据类型。 </p>
<p style="margin-left: 60px;">　　例如：C++、Java、Delphi、C#等。</p>
<p style="margin-left: 60px;">动态语言（弱类型语言）<br />　　动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明， 通常变量的类型是被赋值的那个值的类型。</p>
<p style="margin-left: 60px;">　　 例如：PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。</p>
<p>　　动态语言的特性：</p>
<p>　　　　运行的过程中给对象绑定(添加)属性 </p>
<p>　　　　运行的过程中给类绑定(添加)属性 </p>
<p>　　　　运行的过程中给类绑定(添加)方法 </p>
<p>　　　　运行的过程中删除属性、方法</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Person(object):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name, age):
        self.name </span>=<span style="color: #000000;"> name
        self.age </span>=<span style="color: #000000;"> age

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> show():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">通过类动态增加类方法.</span><span style="color: #800000;">"</span><span style="color: #000000;">)
@classmethod
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> show2(cls):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">通过类动态增加类方法，并且打印id.</span><span style="color: #800000;">"</span><span style="color: #000000;">, cls.id)
    
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">"</span><span style="color: #800000;">__main__</span><span style="color: #800000;">"</span><span style="color: #000000;">:
    person </span>= Person(<span style="color: #800000;">"</span><span style="color: #800000;">张三</span><span style="color: #800000;">"</span>, 22<span style="color: #000000;">)

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 运行过程中，给对象添加属性</span>
    person.phone = <span style="color: #800000;">"</span><span style="color: #800000;">1847015XXXX</span><span style="color: #800000;">"</span>
    <span style="color: #0000ff;">print</span>(person.phone)       <span style="color: #008000;">#</span><span style="color: #008000;"> 1847015XXXX</span>

    <span style="color: #008000;">#</span><span style="color: #008000;"> 运行过程中，对象是不能添加方法，否则会报错</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> person.func = show</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> person.func()</span>

    <span style="color: #008000;">#</span><span style="color: #008000;"> 运行过程中，给类增加属性</span>
    Person.id = 10001
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">对象访问类属性</span><span style="color: #800000;">"</span>, person.id)  <span style="color: #008000;">#</span><span style="color: #008000;"> 对象访问类属性10001</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">类访问类属性</span><span style="color: #800000;">"</span>, Person.id)    <span style="color: #008000;">#</span><span style="color: #008000;">  类访问类属性10001</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 运行过程中给类增加方法</span>
    Person.func =<span style="color: #000000;"> show
    Person.func()               </span><span style="color: #008000;">#</span><span style="color: #008000;">  通过类动态增加类方法.</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 运行过程中给类增加类方法</span>
    Person.func =<span style="color: #000000;"> show2
    Person.func()           </span><span style="color: #008000;">#</span><span style="color: #008000;">   通过类动态增加类方法，并且打印id。10001</span></pre>
</div>
<h2>__slots__</h2>
<p>　　__slots__作用：</p>
<p>　　　　Python允许在定义class的时候，定义一个特殊变量__slots__来限制该 class能添加的属性，当前类就不能定义或者增加__slots__之外的属性了</p>
<p>　　__slots__注意事项：</p>
<p>　　　　__slots__只对类的实例化对象进行限制，不对类进行限制，__slots__变量值是以元组形式表示</p>
<p>　　　　__slots__不仅限制类对象的属性，还限制类对象的方法</p>
<p>　　　　__slots__仅对当前类起作用，对继承的子类不起作用</p>
<p>　　　　在子类中定义__slots__，子类允许定义的属性就是自身的__slots__加上父类的 __slots__</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Person(object):
    </span><span style="color: #800080;">__slots__</span> = (<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name, age):
        self.name </span>=<span style="color: #000000;"> name
        self.age </span>=<span style="color: #000000;"> age
    
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">"</span><span style="color: #800000;">__main__</span><span style="color: #800000;">"</span><span style="color: #000000;">:
    person </span>= Person(<span style="color: #800000;">"</span><span style="color: #800000;">张三</span><span style="color: #800000;">"</span>, 22<span style="color: #000000;">)
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 运行过程中，给对象添加属性实例对象属性只限于name，age </span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> person.phone = "1847015XXXX"</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> print(person.phone)</span>
    
    <span style="color: #008000;">#</span><span style="color: #008000;"> 运行过程中，给类增加属性，__slots__ 不限制类</span>
    Person.id = 10001
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">对象访问类属性</span><span style="color: #800000;">"</span>, person.id)  <span style="color: #008000;">#</span><span style="color: #008000;"> 对象访问类属性 10001</span>
    <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">类访问类属性</span><span style="color: #800000;">"</span>, Person.id)   <span style="color: #008000;">#</span><span style="color: #008000;"> 类访问类属性 10001</span></pre>
</div>
<p>&nbsp;</p>
<h2>生成器</h2>
<p>　　概念：Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<p>　　创建生成器的两种方式：</p>
<p>&nbsp;　　　　方法1：列表生成式的 [ ] 改成 ( )</p>
<p>　　　　　　numbers = ( i for i in range(100))</p>
<p>　　　　　　通过 next() 函数获得生成器的下一个返回值&nbsp;</p>
<p>　　　　　　没有更多的元素时，抛出 StopIteration 的异常&nbsp;</p>
<p>　　　　　　正确的方法是使用 for 循环，因为生成器也是可迭代对象，并且不需要关心 StopIteration 异</p>
<p>&nbsp;　　　　方法2：使用函数创建生成器（实例）</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 斐波那契数列</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> fibonacci(num):
    a </span>=<span style="color: #000000;"> 0
    b </span>= 1<span style="color: #000000;">
    count </span>=<span style="color: #000000;"> 0
    temp </span>= 1
    <span style="color: #0000ff;">while</span> count &lt;<span style="color: #000000;"> num:
        </span><span style="color: #0000ff;">yield</span><span style="color: #000000;"> b
        a, b </span>= b, a+<span style="color: #000000;">b
        count </span>+= 1<span style="color: #000000;">

fi </span>= fibonacci(4<span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span>(next(fi))    <span style="color: #008000;">#</span><span style="color: #008000;"> 1</span>
<span style="color: #0000ff;">print</span>(next(fi))    <span style="color: #008000;">#</span><span style="color: #008000;"> 1</span>
<span style="color: #0000ff;">print</span>(next(fi))    <span style="color: #008000;">#</span><span style="color: #008000;"> 2</span>
<span style="color: #0000ff;">print</span>(next(fi))    <span style="color: #008000;">#</span><span style="color: #008000;"> 3</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> 没有更多的元素时，抛出 StopIteration 的异常</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 正确的方法是使用 for 循环，因为生成器也是可迭代对象，并且不需要关心StopIteration 异常</span>
<span style="color: #0000ff;">print</span>(next(fi))    <span style="color: #008000;">#</span><span style="color: #008000;"> error</span>

<span style="color: #008000;">#</span><span style="color: #008000;"> 所以在使用生成器的时候，需要捕获异常</span>
fi = fibonacci(10<span style="color: #000000;">)
</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(next(fi))
    </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> StopIteration as e:
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(e)
        </span><span style="color: #0000ff;">break</span></pre>
</div>
<p>　　　　另外生成器也可以传递参数通过send(参数值)：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">#</span><span style="color: #008000;"> 斐波那契数列</span>
<span style="color: #0000ff;">def</span><span style="color: #000000;"> fibonacci(num):
    a </span>=<span style="color: #000000;"> 0
    b </span>= 1<span style="color: #000000;">
    count </span>=<span style="color: #000000;"> 0
    temp </span>= 1
    <span style="color: #0000ff;">while</span> count &lt;<span style="color: #000000;"> num:
        temp </span>= <span style="color: #0000ff;">yield</span> temp*<span style="color: #000000;">b
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">temp{}:{}</span><span style="color: #800000;">"</span><span style="color: #000000;">.format(count, temp))
        a, b </span>= b, a+<span style="color: #000000;">b
        count </span>+= 1<span style="color: #000000;">
fi </span>= fibonacci(10<span style="color: #000000;">)

</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(next(fi))
</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">print</span>(fi.send(1<span style="color: #000000;">))
    </span><span style="color: #0000ff;">except</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">break</span></pre>
</div>
<h2>迭代器</h2>
<p>　　可迭代对象：&nbsp;　　</p>
<p>　　　　这里先提一下迭代器对象，如果一个对象可以通for循环进行遍历的对象一般都是迭代器对象；python提供了一个Iterable类就是鉴别对象是否是迭代器对象，在鉴别的过程中需要借助isinstance()方法，这个方法是鉴别对象是否属于一个类的对象，这里不能用type()方法，因为type()的作用是鉴别对象是否是类的实例化对象（通过继承的是false)</p>
<p>　　　　首先先简单介绍两者检验对象类型的区别：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> A:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self):
        </span><span style="color: #0000ff;">pass</span>

<span style="color: #0000ff;">class</span><span style="color: #000000;"> B(A):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self):
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">"</span><span style="color: #800000;">__main__</span><span style="color: #800000;">"</span><span style="color: #000000;">:
    a </span>= 123
    <span style="color: #008000;">#</span><span style="color: #008000;"> 两者检验整型,类似这种，字符串、列表、元组、集合、字典都是一样的结果</span>
    <span style="color: #0000ff;">print</span>(type(a) == int)     <span style="color: #008000;">#</span><span style="color: #008000;"> True</span>
    <span style="color: #0000ff;">print</span>(isinstance(a, int))    <span style="color: #008000;">#</span><span style="color: #008000;"> True</span>
    
    <span style="color: #008000;">#</span><span style="color: #008000;"> 两者主要的区别 直接通过类生成的对象，两者检验的结果是一样的</span>
    b =<span style="color: #000000;"> B()
    </span><span style="color: #0000ff;">print</span>(type(b) == B)    <span style="color: #008000;">#</span><span style="color: #008000;"> True</span>
    <span style="color: #0000ff;">print</span>(isinstance(b, B))    <span style="color: #008000;">#</span><span style="color: #008000;"> True</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 若是父类就会有不一样的结果</span>
    <span style="color: #0000ff;">print</span>(type(b) == A)    <span style="color: #008000;">#</span><span style="color: #008000;"> False</span>
    <span style="color: #0000ff;">print</span>(isinstance(b, A))   <span style="color: #008000;">#</span><span style="color: #008000;"> True</span></pre>
</div>
<p>　　　　所以在检验对象时，采用isinstance()比较好，</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> collections <span style="color: #0000ff;">import</span><span style="color: #000000;"> Iterable

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self):
        </span><span style="color: #0000ff;">pass</span>

<span style="color: #0000ff;">class</span><span style="color: #000000;"> B(A):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self):
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 实例生成器函数</span>
    <span style="color: #0000ff;">def</span><span style="color: #000000;"> func(self, a):
        </span><span style="color: #0000ff;">yield</span><span style="color: #000000;"> a
        a </span>= a + 1
        <span style="color: #0000ff;">if</span> a == 5<span style="color: #000000;">:
            </span><span style="color: #0000ff;">return</span>

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">"</span><span style="color: #800000;">__main__</span><span style="color: #800000;">"</span><span style="color: #000000;">:
    b </span>=<span style="color: #000000;"> B()
    </span><span style="color: #0000ff;">print</span>(isinstance(b, Iterable))   <span style="color: #008000;">#</span><span style="color: #008000;">  False</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 像集合数据类型都是可迭代对象，字符串、列表、元组、集合、字典</span>
    b = <span style="color: #800000;">""</span>
    <span style="color: #0000ff;">print</span>(isinstance(b, Iterable))   <span style="color: #008000;">#</span><span style="color: #008000;"> True</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 前面提到的生成器，他也是可迭代对象</span>
    a =<span style="color: #000000;"> B()
    b </span>=<span style="color: #000000;"> a.func(0)
    </span><span style="color: #0000ff;">print</span>(isinstance(b, Iterable))   <span style="color: #008000;">#</span><span style="color: #008000;"> True</span></pre>
</div>
<p>　　迭代器：</p>
<p>　　　　可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</p>
<p>　　　　可以使用 isinstance() 判断一个对象是否是 Iterator 对象：&nbsp;</p>
<p>　　　　有两种情况是迭代器：</p>
<p>　　　　　　1、通过生成器函数生成的生成器就是迭代器</p>
<p>　　　　　　2、通iter()函数将可迭代对象转换成迭代器</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> collections <span style="color: #0000ff;">import</span><span style="color: #000000;"> Iterator

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self):
        </span><span style="color: #0000ff;">pass</span>

<span style="color: #0000ff;">class</span><span style="color: #000000;"> B(A):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self):
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 实例生成器函数</span>
    <span style="color: #0000ff;">def</span><span style="color: #000000;"> func(self, a):
        </span><span style="color: #0000ff;">yield</span><span style="color: #000000;"> a
        a </span>= a + 1
        <span style="color: #0000ff;">if</span> a == 5<span style="color: #000000;">:
            </span><span style="color: #0000ff;">return</span>

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">"</span><span style="color: #800000;">__main__</span><span style="color: #800000;">"</span><span style="color: #000000;">:
    b </span>=<span style="color: #000000;"> B()
    </span><span style="color: #0000ff;">print</span>(isinstance(b, Iterator))   <span style="color: #008000;">#</span><span style="color: #008000;">  False</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 像集合数据类型都是可迭代对象，字符串、列表、元组、集合、字典</span>
    b = <span style="color: #800000;">""</span>
    <span style="color: #0000ff;">print</span>(isinstance(b, Iterator))   <span style="color: #008000;">#</span><span style="color: #008000;"> True</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> 前面提到的生成器，他也是可迭代对象</span>
    a =<span style="color: #000000;"> B()
    b </span>=<span style="color: #000000;"> a.func(0)
    </span><span style="color: #0000ff;">print</span>(isinstance(b, Iterator))   <span style="color: #008000;">#</span><span style="color: #008000;"> True</span>
    
    <span style="color: #008000;">#</span><span style="color: #008000;"> 通过iter()函数将字符串、列表、元组、集合、字典转换成迭代器</span>
    b =<span style="color: #000000;"> {}
    b </span>=<span style="color: #000000;"> iter(b)
    </span><span style="color: #0000ff;">print</span>(isinstance(b, Iterator))</pre>
</div>
<p>　　　　迭代器是可以自定义，只要重写迭代器协议的两个方法　　　　</p>
<p>　　　　　　迭代器对象符合迭代器协议，提供两种方法： __iter__() 和 __next__()　　　　　　</p>
<p>　　　　　　__iter__ 返回迭代器对象，并在循环开始时隐式调用。&nbsp;</p>
<p>　　　　　　 __next__方法返回下一个值，并在每个循环增量处隐式调用。　　　　</p>
<p>　　　　　　 __next__在没有更多值返回时引发StopIteration异常，循环结构隐式捕获该 异常以停止迭代。&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Counter:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, low, high):
        self.current </span>=<span style="color: #000000;"> low
        self.high </span>=<span style="color: #000000;"> high
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 生成器的一般固定写法</span>
    <span style="color: #0000ff;">def</span> <span style="color: #800080;">__iter__</span><span style="color: #000000;">(self):
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> self
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> 在下面函数可以改变迭代器返回的下一个值</span>
    <span style="color: #0000ff;">def</span> <span style="color: #800080;">__next__</span><span style="color: #000000;">(self):
        </span><span style="color: #0000ff;">if</span> self.current &gt;<span style="color: #000000;"> self.high:
            </span><span style="color: #0000ff;">raise</span><span style="color: #000000;"> StopIteration
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
            self.current </span>+= 2
            <span style="color: #0000ff;">return</span> self.current -2</pre>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>