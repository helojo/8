<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python语法速查： 4. 字符串常用操作' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python语法速查： 4. 字符串常用操作</center></div><div class='banquan'>原文出处:本文由博客园博主初级电路与软件研究提供。<br/>
原文连接:https://www.cnblogs.com/initcircuit/p/11586060.html</div><br>
    <style><!--
td.subtitle { 
  background-color:#FBFBFE;
}

td.name {
  font-family: 'Consolas';
}
td.center {
  text-align:center
}

td.name span{
  font-size: 13px;
  font-style: italic;
  
}
td.name p {
  line-height: 2ex;
}

td.example {
  font-family: 'Consolas';
  color: #606060;
  font-size: 12px;
}

td.example p {  
  line-height: 2ex;
}

td.example p span {
  color: #B0B0B0;
  font-size: 12px;
}
td.example a.advc {
  color: #606060;
}
a.advc {  
  border-bottom:1px solid gray;
  text-decoration:none;
}


h2.dscp span {
  font-style: italic;
}
.codebox {
        display:table-cell;
        width:800px;
        padding-left:20px;
        padding-right:20px;
}
.codebox span {
  color: #909090;
}
a.return {
    color: #BBB;
    font-size:0.8em;
}
--></style>
<p><a class="return" href="https://www.cnblogs.com/initcircuit/p/11849378.html">返回目录</a></p>
<p>&nbsp;</p>
<h2 id="">&nbsp;<span style="font-family: 'Microsoft YaHei';">（1）字符串常用方法</span></h2>
<p style="text-indent: 2em;">Python3中，字符串全都用Unicode形式，所以省去了很多以前各种转换与声明的麻烦。字符串属于序列，所有序列可用的方法（比如切片等）都可用于字符串。</p>
<p style="text-indent: 2em;"><strong>注意：</strong>字符串属于不可变序列，所有处理修改字符的方法，都会生成一个新字符串返回，原字符串不会变。</p>
<table style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="300" /> <col width="300" /> </colgroup>
<thead>
<tr><th style="text-align: center;">字符串方法</th><th style="text-align: center;">简述</th><th style="text-align: center;">举例或说明</th></tr>
</thead>
<tbody><!----- 字符串内容检查 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>字符串内容检查</strong></td>
</tr>
<tr>
<td class="name">s.isalpha()</td>
<td>是否所有字符都为字母</td>
<td class="example">
<p>'abc'.isalpha() <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.islower()</td>
<td>字符串中字母是否都为小写（无视其中的非字母字符）</td>
<td class="example">
<p>'abc'.islower() <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.isupper()</td>
<td>字符串中字母是否都为大写（无视其中的非字母字符）</td>
<td class="example">
<p>'ABC'.isupper() <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.isdecimal()</td>
<td>是否所有字符都为数字0~9（小数点和正负号视作非数字）</td>
<td class="example">
<p>'123'.isdedimal() <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.isdigit()</td>
<td>是否所有字符都为：数字0~9、罗马数字（小数点和正负号视作非数字）</td>
<td class="example">
<p>'Ⅳ'.isdigit() <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.isnumeric()</td>
<td>是否所有字符都为：数字0~9、罗马数字、汉字数字（小数点和正负号视作非数字）</td>
<td class="example">
<p>'一百'.isnumeric() <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.isalnum()</td>
<td>是否所有字符都为字母或数字</td>
<td class="example">
<p>'abc123'.isalnum() <span># 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.isspace()</td>
<td>是否所有字符都为空白</td>
<td class="example">
<p>' \t '.isspace() <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.isprintable()</td>
<td>是否所有字符都可打印。</td>
<td class="example">
<p>'a\t'.isprintable() <span># 结果为 False</span></p>
</td>
</tr>
<tr>
<td class="name">s.isascii()</td>
<td>是否所有字符都为ascii码范围内字符</td>
<td class="example">
<p>'a1#'.isascii() <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.istitle()</td>
<td>是否字符串中每个单词首字母都为大写（若单词首字符为非字母字符，则判断第2个字符，以此类推）</td>
<td class="example">
<p>'Ab 2Cc'.istitle() <span># 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.isidentifier()</td>
<td>字符串内容是否为Python保留字</td>
<td class="example">
<p>'if'.isidentifier() <span># 结果为 True</span></p>
</td>
</tr>
<!----- 子串查找与判断 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>子串查找与判断</strong></td>
</tr>
<tr>
<td class="name">s.startswith(<span>prefix [,start [,end]]</span>)</td>
<td>检查字符串是否以prefix开头，start, end为查找范围（用法同切片）。</td>
<td class="example">
<p>'abc'.startswith('ab') <span>&nbsp; # 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.endswith(<span>suffix [,start [,end]]</span>)</td>
<td>检查字符串是否以suffix结尾，start, end为查找范围（用法同切片）。</td>
<td class="example">
<p>'abc'.endswith('b') <span>&nbsp;&nbsp;&nbsp; # 结果为 False</span></p>
<p>'abc'.endswith('b',0,2) <span># 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">s.find(<span>sub [,start [,end]]</span>)</td>
<td>查找指定字符串sub首次出现的位置，若没找到则返回-1。start, end为查找范围（用法同切片）。</td>
<td class="example">
<p>'abcabc'.find('bc') <span>&nbsp; # 结果为 1</span></p>
</td>
</tr>
<tr>
<td class="name">s.rfind(<span>sub [,start [,end]]</span>)</td>
<td>查找指定字符串sub最后一次出现的位置，若没找到则返回-1，start, end用法同上。</td>
<td class="example">
<p>'abcabc'.rfind('bc') <span>&nbsp; # 结果为 4</span></p>
</td>
</tr>
<tr>
<td class="name">s.index(<span>sub [,start [,end]]</span>)</td>
<td>功能同s.find()，区别是没找到时引发ValueError错误。</td>
<td class="example">
<p>'abcabc'.index('bc') <span>&nbsp; # 结果为 1</span></p>
</td>
</tr>
<tr>
<td class="name">s.rindex(<span>sub [,start [,end]]</span>)</td>
<td>功能同s.rfind()，区别是没找到时引发ValueError错误。</td>
<td class="example">
<p>'abcabc'.index('bc') <span>&nbsp; # 结果为 4</span></p>
</td>
</tr>
<tr>
<td class="name">s.count(<span>sub [,start [,end]]</span>)</td>
<td>统计指定子字符串sub出现的次数，start和end为查找范围（用法同切片）。</td>
<td class="example">
<p>'abc'.count('b',1,1) <span>&nbsp; # 结果为 0</span></p>
<p>'abc'.count('b',1,2) <span>&nbsp; # 结果为 1</span></p>
</td>
</tr>
<!----- 字符串修改 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>字符串修改</strong></td>
</tr>
<tr>
<td class="name">s.lower()</td>
<td>返回新字符串，内容为将原字符串中字母全转成小写（非字母字符则不变）</td>
<td class="example">
<p>'A1B2'.lower() <span>&nbsp; # 返回为 'a1b2'</span></p>
</td>
</tr>
<tr>
<td class="name">s.upper()</td>
<td>返回新字符串，内容为将原字符串中字母全转成大写（非字母字符则不变）</td>
<td class="example">
<p>'a1b2'.upper() <span>&nbsp; # 返回为 'A1B2'</span></p>
</td>
</tr>
<tr>
<td class="name">s.swapcase()</td>
<td>返回新字符串，内容为将原字符串中字母大小写互换（非字母字符则不变）</td>
<td class="example">
<p>'abCD'.swapcase() <span># 返回为 'ABcd'</span></p>
</td>
</tr>
<tr>
<td class="name">s.capitalize()</td>
<td>返回新字符串，内容为将原字符串中每个单词的首字母变为大写。</td>
<td class="example">
<p>'ab cd'.capitalize()</p>
<p><span># 返回为 'Ab Cd;</span></p>
</td>
</tr>
<tr>
<td class="name">s.expandtabs(<span>tabsize=8</span>)</td>
<td>返回新字符串，内容用空格替换制表符，入参为tab对应的空格数。</td>
<td class="example">
<p>a\tb'.expandtabs(4)</p>
<p><span># 返回为 'a&nbsp;&nbsp;&nbsp;&nbsp;b' </span></p>
</td>
</tr>
<tr>
<td class="name">s.replace(<span>old, new [,count]</span>)</td>
<td>返回新字符串，内容为用new替换原字符串中old内容，count可指定替换次数（默认为全部替换）</td>
<td class="example">
<p>'abcdab'.replace('ab','xy')</p>
<p><span># 返回为 'xycdxy'</span></p>
</td>
</tr>
<!----- 字符串格式简单处理 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>字符串格式简单处理</strong></td>
</tr>
<tr>
<td class="name">s.strip(<span>[chars]</span>)</td>
<td>返回新字符串，内容为删掉原字符串中两边的空白。若指定入参chars，则为删掉原字符串两端在入参chars中出现的字符。</td>
<td class="example">
<p>' abc '.strip() <span>&nbsp; # 返回为 'abc'</span></p>
<p>'www.xyz.com'.strip('.cwom')</p>
<p><span># 返回为 'xyz'</span></p>
</td>
</tr>
<tr>
<td class="name">s.lstrip(<span>[chars]</span>)</td>
<td>用法同上，不过仅处理字符串的左边。</td>
<td class="example">
<p>'www.xyz.com'.lstrip('.cwom')</p>
<p><span># 返回为 'xyz.com'</span></p>
</td>
</tr>
<tr>
<td class="name">s.rstrip(<span>[chars]</span>)</td>
<td>用法同上，不过仅处理字符串的右边。</td>
<td class="example">
<p>'www.xyz.com'.rstrip('.cwom')</p>
<p><span># 返回为 www.xyz'</span></p>
</td>
</tr>
<tr>
<td class="name">s.center(<span>width [,fillchar]</span>)</td>
<td>返回新字符串，在长度为width的宽度内将原字符串居中，fillchar为填充单字符</td>
<td class="example">
<p>'abc'.center(9,'*')</p>
<p><span># 返回为 '***abc***'</span></p>
</td>
</tr>
<tr>
<td class="name">s.ljust(<span>width [,fillchar]</span>)</td>
<td>返回新字符串，在长度为width的宽度内将原字符串靠左对齐，fillchar为填充单字符</td>
<td class="example">
<p>'abc'.ljust(9,'*')</p>
<p><span># 返回为 'abc******'</span></p>
</td>
</tr>
<tr>
<td class="name">s.rjust(<span>width [,fillchar]</span>)</td>
<td>返回新字符串，在长度为width的宽度内将原字符串靠右对齐，fillchar为填充单字符</td>
<td class="example">
<p>'abc'.rjust(9,'*')</p>
<p><span># 返回为 '******abc'</span></p>
</td>
</tr>
<tr>
<td class="name">s.zfill(<span>width</span>)</td>
<td>返回新字符串，在原字符串左边填充0，直至其宽度为width</td>
<td class="example">
<p>'abc'.zfill(9)</p>
<p><span># 返回为 '000000abc'</span></p>
</td>
</tr>
<tr>
<td class="name">s.translate(<span>table</span>)</td>
<td>字符映射转换。使用一个转换表table，将字符串中的某个子串映射成另一个子串。转换table由下面的maketrans()方法生成。</td>
<td class="example" rowspan="2">
<p>t=str.maketrans({'ab':'cd'})</p>
<p>'abc'.translate(t)</p>
<p><span># 返回为 'cdc'</span></p>
<p>&nbsp;</p>
<p>t2=str.maketrans('ab','xy')</p>
<p>'abc'.translate(t2)</p>
<p><span># 返回为 'xyc'</span></p>
<p>&nbsp;</p>
<p>t3=str.maketrans('ab','xy',c)</p>
<p>'abc'.translate(t3)</p>
<p><span># 返回为 'xy'</span></p>
</td>
</tr>
<tr>
<td class="name">s.maketrans(<span>x [,y [,z]]</span>)</td>
<td>静态方法。生成一个供上面translate()方法是用的转换表，其中原始子串和映射后子串必须长度相同。若只提供一个参数：x必须为一个字典，键名表示原始子串，值表示映射后子串。若提供2个参数：x表示原始子串，y表示映射后子串。若提供3个参数：x, y含义不变，z表示要删除的子串。</td>
</tr>
<!----- 完整字符串格式化方法 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>完整字符串格式化方法</strong></td>
</tr>
<tr>
<td class="name">s.format(<span>*args, **kwargs</span>)</td>
<td>字符串格式化方法</td>
<td class="example">
<p><a id="t_" class="advc" style="text-decoration: none;" href="https://www.cnblogs.com/initcircuit/p/11574434.html#h_title_2">用法详见&ldquo;字符串格式化&rdquo;篇</a></p>
</td>
</tr>
<tr>
<td class="name">s.format_map(<span>mapping</span>)</td>
<td>Python3.2新增方法，可以直接使用字典作为输入参数进行字符串格式化。</td>
<td class="example">
<p>比较：format()与format_map()</p>
<p>'Hi {name}!'.format(name='Tom')</p>
<p><span># 结果为 'Hi Tom!'</span></p>
<p>&nbsp;</p>
<p>d={'name':'Tom'}</p>
<p>'Hi {name}!'.format_map(d)</p>
<p><span># 结果为 'Hi Tom!'</span></p>
</td>
</tr>
<!----- 字符串分割与拼接 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>字符串分割与拼接</strong></td>
</tr>
<tr>
<td class="name">s.split(<span>sep=None, maxsplit=-1</span>)</td>
<td>将字符串以sep作为分隔符进行划分，将划分后的每个片段子串排成一个列表返回。maxsplit是划分的最大次数（默认-1为不设上限）。若在字符串中没找到指定分隔符，则将原字符串作为单一元素放入列表。</td>
<td class="example">
<p>'a,b,c'.split(',')</p>
<p><span># 结果为 ['a','b','c']</span></p>
</td>
</tr>
<tr>
<td class="name">s.rsplit(<span>sep=None, maxsplit=-1</span>)</td>
<td>用法同上，只不过是从右边开始划分字符串，列表中内容的顺序仍旧为从左到右。详见右例。</td>
<td class="example">
<p>'a,b,c'.rsplit(',',maxsplit=1)</p>
<p><span># 结果为 ['a,b','c']</span></p>
<p>'a,b,c'.rsplit(',')</p>
<p><span># 结果仍为 ['a','b','c']</span></p>
</td>
</tr>
<tr>
<td class="name">splitlines(<span>[keepends]</span>)</td>
<td>将多行字符串按行进行分隔成列表，若参数keepends为True，则保留每行后的换行符。</td>
<td class="example">
<p>x="""a</p>
<p>b"""</p>
<p>x.splitlines()</p>
<p><span># 结果为 ['a','b']</span></p>
<p>x.splitlines(True)</p>
<p><span># 结果为 ['a\n','b']</span></p>
</td>
</tr>
<tr>
<td class="name">s.partition(<span>sep</span>)</td>
<td>用分隔符字符串sep划分字符串，返回一个元祖(head, sep, tail)。若没找到sep，则返回(s, "", "")</td>
<td class="example">
<p>'a;b;c'.partition(';')</p>
<p><span># 结果为 ('a', ';', 'b;c')</span></p>
</td>
</tr>
<tr>
<td class="name">s.rpartition(<span>sep</span>)</td>
<td>用法同上，只不过是从右边开始划分字符串，详见右例。</td>
<td class="example">
<p>'a;b;c'.rpartition(';')</p>
<p><span># 结果为 ('a;b', ';', 'c')</span></p>
</td>
</tr>
<tr>
<td class="name">s.join(<span>iter</span>)</td>
<td>用s作为分隔符，将iter中所有迭代对象拼接成一个字符串返回。</td>
<td class="example">
<p>';'.join('abc')</p>
<p><span># 结果为 'a;b;c'</span></p>
<p>';'.join(['ab','cd'])</p>
<p><span># 结果为 'ab;cd'</span></p>
</td>
</tr>
<!----- 字符串编码 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>字符串编码</strong></td>
</tr>
<tr>
<td class="name">s.encoding(<span>encoding="utf-8", errors="sctrict"</span>)</td>
<td>返回字符串的编码后字节流版本，返回类型为bytes。默认为严格检错模式，只要在转换过程中发现错误，即引发UnicodeError错误。</td>
<td class="example">
<p>常用的encoding参数：</p>
<p>'ascii'、'utf-16'、'utf-32'、</p>
<p>'gb2312'（国标）、</p>
<p>'gbk' (gb2312的超集)</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="">&nbsp;<span style="font-family: 'Microsoft YaHei';">（2）字符串常量</span></h2>
<p style="text-indent: 2em;">string模块包含很多有用的常量，详见下表：</p>
<table style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="240" /> </colgroup>
<thead>
<tr><th style="text-align: center;">常量</th><th style="text-align: center;">简述</th></tr>
</thead>
<tbody>
<tr>
<td class="name">string.digits</td>
<td>字符串 '0123456789'</td>
</tr>
<tr>
<td class="name">string.octdigits</td>
<td>字符串 '01234567'</td>
</tr>
<tr>
<td class="name">string.hexdigits</td>
<td>字符串 '0123456789abcdefABCDEF'</td>
</tr>
<tr>
<td class="name">string.ascii_lowercase</td>
<td>字符串 'abcdefghijklmnopqrstuvwxyz'</td>
</tr>
<tr>
<td class="name">string.ascii_uppercase</td>
<td>字符串 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</td>
</tr>
<tr>
<td class="name">string.ascii_letters</td>
<td>字符串 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</td>
</tr>
<tr>
<td class="name">string.punctuation</td>
<td>由ASCII标点符号字符组成的字符串</td>
</tr>
<tr>
<td class="name">string.whitespace</td>
<td>包括：空格、制表符（\t）、换行（\n）、回车（\r）、垂直制表符（\v）、换页（\f）</td>
</tr>
<tr>
<td class="name">string.printable</td>
<td>可打印字符组成的字符串，是digits, ascii_letters, punctuation, whitespace的组合</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="">&nbsp;<span style="font-family: 'Microsoft YaHei';">（3）模板字符串Template</span></h2>
<p style="text-indent: 2em;">string模块的Template类型也可以进行简单的&ldquo;字符串格式化&rdquo;。用法如下：</p>
<p style="text-indent: 2em;">（1）生成一个Template对象（其中用$表示以后将要代入的变量）；</p>
<p style="text-indent: 2em;">（2）对此对象调用substitute(m [,**kwargs])方法，将数据传入并生成格式化后的字符串。 可以用字典m来传入数据，也可以用后面关键字参数**kwargs的方法传入数据。</p>
<p style="text-indent: 2em;">详见下例：</p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code>&gt;&gt;&gt;  t=string.Template('$name is $age')<span>&nbsp;&nbsp;&nbsp;&nbsp;# 生成Template类型的对象实例<em>t</em></span>
&gt;&gt;&gt;  t.substitute({'name':'Tom', 'age':6})<span>&nbsp;# 用字典传入数据，结果为 'Tom is 6'</span>
&gt;&gt;&gt;  t.substitute(name='Tom', age=6)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 用关键字参数传入数据，结果同上</span></pre>
</div>
</div>
<p style="text-indent: 2em;">还可以用它的template属性来查看原始字符串：</p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code>&gt;&gt;&gt;  print(t.template)<span>&nbsp;&nbsp;&nbsp;&nbsp;# 结果为：'$name is $age'</span></pre>
</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="">&nbsp;<span style="font-family: 'Microsoft YaHei';">（4）正则表达式</span></h2>
<p style="text-indent: 2em;">Python的re模块用于正则表达式。可以使用re模块的方法直接进行正则表达式的匹配和替换，也可以将正则表达式先编译成一个&ldquo;正则表达式对象&rdquo;，然后再使用这个正则表达式对象的方法进行字符串匹配和替换，下面我们分别进行介绍。</p>
<p style="text-indent: 2em;">另外，由于正则表达式中大量使用特殊字符和反斜杠，所以正则表达式通常都写为&ldquo;原始字符串&rdquo;（即在字符串前加上字母r），原始字符串中，所有的特殊字符不会被转义，如&ldquo;r'\nabc'前面的'\n'不会被解释为换行符，仅仅就是字面意思的斜杠和n。</p>
<p style="text-indent: 2em;">本篇仅介绍re模块的用法，关于正则表达式本身的详细语法，可点击查看这里：<a href="https://www.cnblogs.com/initcircuit/p/10754680.html">《正则表达式用法简介与速查》</a>。</p>
<p>&nbsp;</p>
<p><strong>● re模块的直接方法</strong></p>
<p>使用下面的方法需先：import re</p>
<table style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="260" /> <col width="280" /> </colgroup>
<thead>
<tr><th style="text-align: center;">方法</th><th style="text-align: center;">简述</th><th style="text-align: center;">举例或说明</th></tr>
</thead>
<tbody>
<tr>
<td class="name">re.compile(<span>patt, flags=0</span>)</td>
<td>将入参patt编译为&ldquo;正则表达式对象&rdquo;， <a class="advc" style="text-decoration: none;" href="#h_flag">flag含义详见下述</a></td>
<td class="example">
<p>关于正则表达式对象的用法 <a class="advc" style="text-decoration: none;" href="#h_compile">详见下述。</a></p>
</td>
</tr>
<tr>
<td class="name">re.escape(<span>string</span>)</td>
<td>返回一个字符串，其中所有与正则表达式相关的特殊字符前都带有反斜杠。</td>
<td class="example">
<p>re.escape('ab12[]') <span> # 返回为 'ab12\[\] </span></p>
</td>
</tr>
<tr>
<td class="name">re.findall(<span>patt, string, flags=0</span>)</td>
<td>在 string 中匹配 patt，匹配结果用一列表返回。 <a class="advc" style="text-decoration: none;" href="#h_flag">flag含义详见下述</a></td>
<td class="example">
<p>re.findall('\d', 'a12b2')</p>
<p><span># 结果为 ['1','2','2']</span></p>
</td>
</tr>
<tr>
<td class="name">re.finditer(<span>patt, string, flags=0</span>)</td>
<td>与上面 findall()的用法相同（在string 中匹配 patt），但返回一个含MatchObject类型的迭代器对象。 <a class="advc" style="text-decoration: none;" href="#h_matchobject">MatchObject详见下述。</a></td>
<td class="example">
<p>re.finditer('\d', 'a12b2')</p>
<p><span># 结果为一个MatchObject类型的迭代器</span></p>
</td>
</tr>
<tr>
<td class="name">re.search(<span>patt, string, flags=0</span>)</td>
<td>与上面 finditer()的用法相同（在string 中匹配 patt），但仅返回第一个匹配的MatchObject对象，若未找到匹配则返回None。 <a class="advc" style="text-decoration: none;" href="#h_matchobject">MatchObject详见下述。</a></td>
<td class="example">
<p>m=re.search('\d', 'a12b2')</p>
<p>print(m.group(0)) <span>&nbsp; # 结果为 '1' </span></p>
</td>
</tr>
<tr>
<td class="name">re.match(<span>patt, string, flags=0</span>)</td>
<td>与上面 search()的用法相同（在string 中匹配 patt，仅返回第一个匹配的MathchObject对象），但仅匹配string的开头部分。 <a class="advc" style="text-decoration: none;" href="#h_matchobject">MatchObject详见下述。</a></td>
<td class="example">
<p>re.match('\d', 'a12') <span>&nbsp; # 结果为 None</span></p>
<p>re.match('\d', '21a') <span>&nbsp; # 结果为有匹配</span></p>
</td>
</tr>
<tr>
<td class="name">re.split(<span>patt, string, maxsplit=0, flags=0</span>)</td>
<td>根据patt出现的位置拆分string，返回字符串列表。maxsplit为最大拆分次数，其他参数含义同上。</td>
<td class="example">
<p>re.split('\d', 'a1b23c4')</p>
<p><span># 结果为 ['a','b','','c','']</span></p>
</td>
</tr>
<tr>
<td class="name">re.sub(<span>patt, repl, string, count=0, flags=0</span>)</td>
<td>使用替换值repl替换string中的patt匹配处内容，返回替换后的新字符串。count是执行替换的最大次数，其他参数含义同上。</td>
<td class="example">
<p>re.sub('\d','x','a1b23c')</p>
<p><span># 结果为 'axxbxc'</span></p>
</td>
</tr>
<tr>
<td class="name">re.subn(<span>patt, repl, string, count=0, flags=0</span>)</td>
<td>与上面 sub()相同（使用替换值repl替换string中的patt匹配处内容），但返回一个元组，其中包含新字符串和替换次数</td>
<td class="example">
<p>re.subn('\d','x','a1b23c')</p>
<p><span># 结果为 ('axxbxc', 3)</span></p>
</td>
</tr>
<tr>
<td class="name">re.purge()</td>
<td>清空正则表达式的缓存内容</td>
<td class="example">
<p>一般用于含子表达式时的情况</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p id="h_flag">&nbsp;flag标志：各标志本质上为一个整数值，多个标志同时使用时，中间用&ldquo;或&rdquo;运算符合并。</p>
<table style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="100" /> <col width="200" /> <col width="80" /> </colgroup>
<thead>
<tr><th style="text-align: center;">缩写</th><th style="text-align: center;">全称</th><th style="text-align: center;">整数值</th><th style="text-align: center;">含义说明</th></tr>
</thead>
<tbody>
<tr>
<td class="center">re.A</td>
<td>re.ASCII</td>
<td class="center">256</td>
<td>
<p>执行仅8位ASCII字符匹配</p>
</td>
</tr>
<tr>
<td class="center">re.I</td>
<td>re.IGNORECASE</td>
<td class="center">2</td>
<td>
<p>执行不区分大小写的匹配</p>
</td>
</tr>
<tr>
<td class="center">re.L</td>
<td>re.LOCALE</td>
<td class="center">4</td>
<td>
<p>为\w、\W、\b、\B 使用地区设置</p>
</td>
</tr>
<tr>
<td class="center">re.M</td>
<td>re.MULTILINE</td>
<td class="center">8</td>
<td>
<p>将^和$应用于多行字符串的的每一行（正常情况下，^和$仅用于匹配整个字符串的开头和结尾）。</p>
</td>
</tr>
<tr>
<td class="center">re.S</td>
<td>re.DOTALL</td>
<td class="center">16</td>
<td>
<p>使点字符&ldquo;.&rdquo;匹配所有字符，包括换行符</p>
</td>
</tr>
<tr>
<td class="center">re.U</td>
<td>re.UNICODE</td>
<td class="center">32</td>
<td>
<p>使用Unicode（Python3默认标志）</p>
</td>
</tr>
<tr>
<td class="center">re.X</td>
<td>re.VERBOSE</td>
<td class="center">64</td>
<td>
<p>忽略模式字符串中未转义的空格和注释</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p id="h_compile"><strong>● 正则表达式对象的使用方法</strong></p>
<p style="text-indent: 2em;">由re.compile()函数编译创建的正则表达式对象，具有以下属性和方法：</p>
<table style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="260" /> <col width="280" /> </colgroup>
<thead>
<tr><th style="text-align: center;">属性或方法</th><th style="text-align: center;">简述</th><th style="text-align: center;">举例或说明</th></tr>
</thead>
<tbody><!----- 属性 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>属性</strong></td>
</tr>
<tr>
<td class="name">flags</td>
<td>在使用complie编译正则表达式时使用的flags参数，为一个整数。</td>
<td class="example">
<p>r=re.compile('a')</p>
<p>print(r.flags) <span>&nbsp; # 结果为 32</span></p>
</td>
</tr>
<tr>
<td class="name">groupindex</td>
<td>一个字典，对类似(?P&lt;name&gt;...)的扩展正则表达式，将其定义的各符号分组名映射到数字编号。</td>
<td class="example">
<p>r=re.compile('(?P&lt;a1&gt;\d)(?P&lt;a2&gt;abc)')</p>
<p>print(r.groupindex)</p>
<p><span># 结果为 {'a1':1, 'a2':2}</span></p>
</td>
</tr>
<tr>
<td class="name">pattern</td>
<td>本正则表达式对象在compile()编译前的原始表达字符串</td>
<td class="example">
<p>略</p>
</td>
</tr>
<!----- 方法 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>方法</strong></td>
</tr>
<tr>
<td class="name">findall(<span>str [,pos [,endpos]]</span>)</td>
<td>等效于前面的re.findall()函数（在 string 中匹配本正则对象，匹配结果用一列表返回），pos和endpos指定搜索的开始和结束位置。</td>
<td class="example">
<p>r=re.compile('\d')</p>
<p>r.findall('a12b2')</p>
<p><span># 结果为 ['1','2','2']</span></p>
</td>
</tr>
<tr>
<td class="name">finditer(<span>str [,pos [,endpos]]</span>)</td>
<td>等效于前面的re.finditer()函数（在string 中匹配本正则对象，返回一个含MatchObject类型的迭代器对象），pos和endpos含义同上。</td>
<td class="example">
<p>r=re.compile('\d')</p>
<p>r.finditer('a12b2')</p>
<p><span># 结果为一个MatchObject类型的迭代器</span></p>
</td>
</tr>
<tr>
<td class="name">search(<span>str [,pos [,endpos]]</span>)</td>
<td>等效于前面的re.search()函数（在string 中匹配本正则对象，但仅返回第一个匹配的MatchObject对象），pos和endpos含义同上。</td>
<td class="example">
<p>r=re.compile('\d')</p>
<p>m=r.search('a12b2')</p>
<p>print(m.group(0)) <span>&nbsp; # 结果为 '1'</span></p>
</td>
</tr>
<tr>
<td class="name">match(<span>str [,pos [,endpos]]</span>)</td>
<td>等效于前面的re.match()函数（在string 中匹配本正则对象，仅返回第一个匹配的MathchObject对象，且仅匹配string的开头部分），pos和endpos含义同上。</td>
<td class="example">
<p>r=re.compile('\d')</p>
<p>m=r.match('a12b2') <span>&nbsp; # 结果为 None</span></p>
</td>
</tr>
<tr>
<td class="name">split(<span>str, maxsplit=0</span>)</td>
<td>等效于前面的re.split()函数（根据本正则对象出现的位置拆分string，返回字符串列表，maxsplit为最大拆分次数）。</td>
<td class="example">
<p>r=re.compile('\d')</p>
<p>r.split('a1b23c4')</p>
<p><span># 结果为 ['a','b','','c','']</span></p>
</td>
</tr>
<tr>
<td class="name">sub(<span>repl, str, count=0</span>)</td>
<td>等效于前面的re.sub()函数（使用替换值repl替换string中的本正则对象匹配处内容，返回替换后的新字符串。count是执行替换的最大次数）。</td>
<td class="example">
<p>r=re.compile('\d')</p>
<p>r.sub('x','a1b23c')</p>
<p><span># 结果为 'axxbxc'</span></p>
</td>
</tr>
<tr>
<td class="name">subn(<span>repl, str, count=0</span>)</td>
<td>等效于前面的re.subn()函数（使用替换值repl替换string中的本正则对象匹配处内容，返回一个元组，其中包含新字符串和替换次数）。</td>
<td class="example">
<p>r=re.compile('\d')</p>
<p>r.subn('x','a1b23c')</p>
<p><span># 结果为 ('axxbxc', 3)</span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p id="h_matchobject"><strong>● MatchObject详解：</strong></p>
<p style="text-indent: 2em;">MatchObject实例包含若干匹配的完整信息，它具有以下属性和方法</p>
<table style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="260" /> <col width="280" /> </colgroup>
<thead>
<tr><th style="text-align: center;">属性或方法</th><th style="text-align: center;">简述</th><th style="text-align: center;">举例或说明</th></tr>
</thead>
<tbody><!----- 属性 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>属性</strong></td>
</tr>
<tr>
<td class="name">pos</td>
<td>传递给search()或match()函数的pos值</td>
<td class="example">
<p>略</p>
</td>
</tr>
<tr>
<td class="name">endpos</td>
<td>传递给search()或match()函数的endpos值</td>
<td class="example">
<p>略</p>
</td>
</tr>
<tr>
<td class="name">lastindex</td>
<td>在使用子表达式时，相匹配的最后一个子表达式的数字索引（从1开始），若没有匹配的子表达式，则为None。</td>
<td class="example">
<p>r=re.compile('(a)(b)')</p>
<p>m=r.search('abc')</p>
<p>print(m.lastindex) <span>&nbsp; # 结果为 2</span></p>
<p><span># 解释：第2个子表达式为'b'，有匹配，故最后一个匹配的子表达式的索引为2 </span></p>
</td>
</tr>
<tr>
<td class="name">lastgroup</td>
<td>在使用子表达式时，相匹配的最后一个子表达式的给定名称，如果没有相匹配的子表达式，或正则表达式中没有给定名称的子表达式，则为None。</td>
<td class="example">
<p>r=re.compile('(?P&lt;a1&gt;a)(?P&lt;a2&gt;b)')</p>
<p>m=r.search('abc')</p>
<p>print(m.lastgroup) <span>&nbsp; # 结果为 a2</span></p>
<p><span># 解释：第2个子表达为'b'，有匹配，且第2个子表达式被命名为'a2'，故最后结果显式为'a2' </span></p>
</td>
</tr>
<tr>
<td class="name">re</td>
<td>一个正则表达式对象，它的match()或search()方法生成此MatchObject实例。</td>
<td class="example">
<p>r=re.compile('a')</p>
<p>m=r.search('abc')</p>
<p>print(m.re)</p>
<p><span># 结果为 re.compile('a')</span></p>
</td>
</tr>
<tr>
<td class="name">string</td>
<td>传递给match()或search()的字符串。</td>
<td class="example">
<p>略</p>
</td>
</tr>
<!----- 方法 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>方法</strong></td>
</tr>
<tr>
<td class="name">expand(<span>template</span>)</td>
<td>返回一个字符串，该字符串可通过在字符串template上使用反斜杠来提取出被匹配的内容（若使用子表达数字索引，需要使用双反斜杠）。</td>
<td class="example">
<p>r=re.compile('(?P&lt;a1&gt;a)(?P&lt;a2&gt;b)')</p>
<p>m=r.search('abc')</p>
<p>m.expand('\\1') <span>&nbsp; # 结果为 'a'</span></p>
<p>m.expand('\g&lt;a2&gt;') <span>&nbsp; # 结果为 'b'</span></p>
</td>
</tr>
<tr>
<td class="name">group(<span>[grp1, grp2, ...]</span>)</td>
<td>返回匹配的一个或多个子表达式，参数grp1,grp2,... 为子表达式的索引或给定名称。若不指定入参或入参为0，则返回整个匹配值。</td>
<td class="example">
<p>r=re.compile('(?P&lt;a1&gt;a)(?P&lt;a2&gt;b)')</p>
<p>m=r.search('abc')</p>
<p>m.group(0) <span>&nbsp; # 结果为 'ab'</span></p>
<p>m.group(1) <span>&nbsp; # 结果为 'a'</span></p>
<p>m.group('a2') <span>&nbsp; # 结果为 'b'</span></p>
<p>m.group(1,'a2') <span>&nbsp; # 结果为 ('a','b')</span></p>
</td>
</tr>
<tr>
<td class="name">[]</td>
<td>Python3.6新增功能，可以使用[]操作符来返回匹配的子表达式，数字索引含义同上。</td>
<td class="example">
<p>续上例</p>
<p>m[0] <span>&nbsp; # 结果为 'ab'</span></p>
<p>m[1] <span>&nbsp; # 结果为 'a'</span></p>
<p>m[2] <span>&nbsp; # 结果为 'b'</span></p>
</td>
</tr>
<tr>
<td class="name">
<p>start(<span>[group]</span>)</p>
<p>end(<span>[group]</span>)</p>
</td>
<td>这两个方法返回匹配的子表达式在原字符串中的开始和结束索引（end的含义同切片，为结束位置的后1个位置）。若不指定group，将使用相匹配的整个字符串。</td>
<td class="example">
<p>续上例</p>
<p>m.start() <span>&nbsp; # 结果为 0</span></p>
<p>m.end() <span>&nbsp; # 结果为 2</span></p>
<p>m.start(1) <span>&nbsp; # 结果为 0</span></p>
<p>m.start(2) <span>&nbsp; # 结果为 1</span></p>
</td>
</tr>
<tr>
<td class="name">span(<span>[group]</span>)</td>
<td>返回一个元组，内容为（m.start([group], m.end([group]))</td>
<td class="example">
<p>续上例</p>
<p>m.span() <span>&nbsp; # 结果为 (0,2)</span></p>
<p>m.span(1) <span>&nbsp; # 结果为 (0,1)</span></p>
<p>m.span(2) <span>&nbsp; # 结果为 (1,2)</span></p>
</td>
</tr>
<tr>
<td class="name">groups(<span>default=None</span>)</td>
<td>返回一个元组，其中每个元素为各个子表达式匹配的文本，若某子表达式未找到匹配，则对应元素为None（若指定入参defalut，则将对应的None元素替换为defalut）</td>
<td class="example">
<p>r=re.compile('(?P&lt;a1&gt;a)(?P&lt;a2&gt;b)<strong>?</strong>')</p>
<p>m=r.search('axy')</p>
<p>m.groups() <span>&nbsp; # 结果为 ('a', None)</span></p>
<p>m.groups('z') <span>&nbsp; # 结果为 ('a', 'z')</span></p>
</td>
</tr>
<tr>
<td class="name">groupdict(<span>default=None</span>)</td>
<td>返回一个字典，其中包含所有给定名称的子表达式匹配，default含义同上。</td>
<td class="example">
<p>续上例</p>
<p>m.groupdict()<span>&nbsp;#结果为{'a1':'a', 'a2':None}</span></p>
<p>m.groupdict('z')<span>&nbsp;#结果为{'a1':'a', 'a2':'z'}</span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a class="return" href="https://www.cnblogs.com/initcircuit/p/11849378.html">返回目录</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>