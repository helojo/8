<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修1.2python基础_数字类型_数字(Number)类型' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>1.2python基础_数字类型_数字(Number)类型</center></div><div class='banquan'>原文出处:本文由博客园博主AI_方程式提供。<br/>
原文连接:https://www.cnblogs.com/AILHQ/p/11663735.html</div><br>
    <h1><strong>一、整型（int型、整数）</strong></h1>
<p><strong>整型</strong>&nbsp;等价于C中的有符号长整型（long）</p>
<p>与系统的最大整型一致（如32位机器上的整型是32位，64位机器上的整型是64位），</p>
<p>可以表示的整数范围在[-sys.maxint-1, sys.maxint]之间。整型字面值的表示方法有3种：</p>
<p>十进制（常用）、八进制（以数字&ldquo;0&rdquo;开头）和十六进制（以&ldquo;0x&rdquo;或&ldquo;0X&rdquo;开头）。</p>
<p>整型的标准库操作有如下</p>
<div class="cnblogs_Highlighter">
<pre><code>class int(object):
    """
    int(x，底=10)-&gt;整数将一个数字或字符串转换成整数，
    如果没有给出参数，则转换为orreturn0if。如果x是一个数字，
    则返回x. int_()。对于浮点数，它会向零截断如果x不是一个数字，
    或者给定了基数，那么x必须是一个字符串、字节或hutearray实例，
    表示给定基数中的整数字面值。文字的前面可以加&ldquo;或&rdquo;。然后被空白包围。
    基数默认为10。有效的基数是0和2-36。Base 0表示将字符串的Base解释为整数文字。
    int (&ldquo;0 b100' = 0)基地

    """

    def bit_length(self):  # real signature unknown; restored from __doc__

        """ 返回表示该数字的时占用的最少位数

        &gt;&gt;&gt; bin(37)#bin()是返回二进制后面有
        '0b100101'
        &gt;&gt;&gt; (37).bit_length()
        6
        """
        pass

    def conjugate(self, *args, **kwargs):  # real signature unknown
        """ 返回该复数的共轭复数"""
        """
            a=123-12j           #复数没有实部时要补0.0
            返回该复数的共轭复数
            b=a.conjugate()
            print(b)
            #返回复数的实数部分
            a.real 
            #返回复数的虚数部分
            a.imag
        
        """
        pass

    @classmethod  # known case
    def from_bytes(cls, *args, **kwargs):  # real signature unknown
        """
        功能：res =&nbsp;int.from_bytes(x)的含义是把bytes类型的变量x，
              转化为十进制整数，并存入res中。
              其中bytes类型是python3特有的类型。

        函数参数：int.from_bytes(bytes, byteorder, *, signed=False)。
                在IDLE或者命令行界面中使用help(int.from_bytes)命令可以查看具体介绍。
                bytes是输入的变量；byteorder主要有两种：
                'big'和'little'；signed=True表示需要考虑符号位
        举例说明：int_s&nbsp; =&nbsp;int.from_bytes(s, byteorder='little', signed=True)，
                 其中s='\xf1\xff'，则输出int_s=-15。分析一下过程，
                 '\x'表示十六进制数，先把'f1'写成二进制数：1111 0001，
                 'ff'同上：1111 1111.由于s的高低位标志是'little'，
                 即'f1'是低位，'ff'是高位，所以正确的顺序应该是'fff1'，
                 即11111111 1111 0001.又因为要考虑符号位，第一位是1，所以s是负数，
                 要进行取反加一才是正确的十进制数（第一位符号位的1不变），
                 可以得到10000000 00001111，写成十进制，就是-15，也就是int_s的结果。
                 上面的例子中，如果signed=False，则无符号位；若byteorder='big'，
                 则输入s的左边是高位，右边是低位。
            &gt;&gt;&gt; s1 = b'\xf1\xff'
            &gt;&gt;&gt; print(int.from_bytes(s1, byteorder='little', signed=True))
                -15
            &gt;&gt;&gt; print(int.from_bytes(s1, byteorder='big', signed=False))
                61951
            &gt;&gt;&gt; s2 = b'\xff\xf1'
            &gt;&gt;&gt; print(int.from_bytes(s2, byteorder='little', signed=False))
                61951
        """
        pass

    def to_bytes(self, *args, **kwargs):  # real signature unknown
        """
        参照上面from_bytes(cls, *args, **kwargs):
        这是上面的逆运算
        """
        pass

    def __abs__(self, *args, **kwargs):  # real signature unknown
        """返回绝对值"""
        """ x.__abs__() &lt;==&gt; abs(x) """
        """ abs(self) """
        """
        a=-100
        b=abs(a)
        c=a.__abs__()
        print(b)
        print(c)
        """
        pass

    def __add__(self, *args, **kwargs):  # real signature unknown
        """ 加法，也可区分数字和字符串"""

        """ x.__add__(y) &lt;==&gt; x+y """
        """
        a=10
        b=20
        c=a.__add__(b)
        d=a+b
        print(c)
        print(d)
        """
        pass

    def __and__(self, *args, **kwargs):  # real signature unknown
        """ Return self&amp;value. """
        """ x.__and__(y) &lt;==&gt; x&amp;y """
        """
            &amp;	按位与运算符：参与运算的两个值,
                如果两个相应位都为1,则该位的结果为1,
                否则为0(其他情况都为0)
        """
        """
         a=1
         b=1
         c=a.__and__(b)
         d=a&amp;b
         print(c)
         print(d)
        """
        pass

    def __bool__(self, *args, **kwargs):  # real signature unknown
        """ self != 0 """
        """等于0返回False 其他返回True  """
        """
        False
        True
        True
        """
        pass

    def __ceil__(self, *args, **kwargs):  # real signature unknown
        """ Ceiling of an Integral returns itself. """
        pass

    def __divmod__(self, *args, **kwargs):  # real signature unknown
        """ Return divmod(self, value). """
        """  返回一个元组，第一个元素为商，第二个元素为余数"""
        """
        a=14
        b=3
        c=(a).__divmod__(b)
        print(c)
        """
        pass

    def __eq__(self, *args, **kwargs):  # real signature unknown
        """ Return self==value. """
        """ 判断两个值是否相等"""
        """
        a=14
        b=3
        c=(a).__eq__(b)
        d=(a).__eq__(14)
        print(c)
        print(d)
        """
        pass

    def __float__(self, *args, **kwargs):  # real signature unknown
        """ float(self) """
        """转换成floa型，将一个整数转换成浮点型"""
        """ x.__float__() &lt;==&gt; float(x) """
        """
        a=100
        b=(a).__float__()
        print(b)
        """
        pass

    def __floordiv__(self, *args, **kwargs):  # real signature unknown
        """ Return self//value. """
        """整除，保留结果的整数部分"""
        """a//b"""
        """
        a=100
        b=a.__floordiv__(27)
        c=a//27
        print(b)
        print(c)
        """
        pass

    def __floor__(self, *args, **kwargs):  # real signature unknown
        """ Flooring an Integral returns itself. """
        """返回本身"""
        """
        a=100
        b=a.__floor__()
        print(b)
        """
        pass

    def __format__(self, *args, **kwargs):  # real signature unknown
        """转换对象的类型"""
        """
        a=100
        b=a.__format__('f')
        c=a.__format__("0x")
        d=a.__format__("b")
        print(b)
        print(c)
        print(d)
        """
        pass

    def __getattribute__(self, *args, **kwargs):  # real signature unknown
        """ Return getattr(self, name). """
        """"""
        pass

    def __getnewargs__(self, *args, **kwargs):  # real signature unknown

        pass

    def __ge__(self, *args, **kwargs):  # real signature unknown
        """ Return self&gt;=value. """
        pass

    def __gt__(self, *args, **kwargs):  # real signature unknown
        """ Return self&gt;value. """
        pass

    def __hash__(self, *args, **kwargs):  # real signature unknown
        """ Return hash(self). """
        pass

    def __index__(self, *args, **kwargs):  # real signature unknown
        """ Return self converted to an integer, if self is suitable for use as an index into a list. """
        pass

    def __init__(self, x, base=10):  # known special case of int.__init__
        """
        int([x]) -&gt; integer
        int(x, base=10) -&gt; integer

        Convert a number or string to an integer, or return 0 if no arguments
        are given.  If x is a number, return x.__int__().  For floating point
        numbers, this truncates towards zero.

        If x is not a number or if base is given, then x must be a string,
        bytes, or bytearray instance representing an integer literal in the
        given base.  The literal can be preceded by '+' or '-' and be surrounded
        by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
        Base 0 means to interpret the base from the string as an integer literal.
        &gt;&gt;&gt; int('0b100', base=0)
        4
        # (copied from class doc)
        """
        pass

    def __int__(self, *args, **kwargs):  # real signature unknown
        """ int(self) """
        pass

    def __invert__(self, *args, **kwargs):  # real signature unknown
        """ ~self """
        pass

    def __le__(self, *args, **kwargs):  # real signature unknown
        """ Return self&lt;=value. """
        pass

    def __lshift__(self, *args, **kwargs):  # real signature unknown
        """ Return self&lt;&lt;value. """
        pass

    def __lt__(self, *args, **kwargs):  # real signature unknown
        """ Return self&lt;value. """
        pass

    def __mod__(self, *args, **kwargs):  # real signature unknown
        """ Return self%value. """
        pass

    def __mul__(self, *args, **kwargs):  # real signature unknown
        """ Return self*value. """
        pass

    def __neg__(self, *args, **kwargs):  # real signature unknown
        """ -self """
        pass

    @staticmethod  # known case of __new__
    def __new__(*args, **kwargs):  # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __ne__(self, *args, **kwargs):  # real signature unknown
        """ Return self!=value. """
        pass

    def __or__(self, *args, **kwargs):  # real signature unknown
        """ Return self|value. """
        pass

    def __pos__(self, *args, **kwargs):  # real signature unknown
        """ +self """
        pass

    def __pow__(self, *args, **kwargs):  # real signature unknown
        """ Return pow(self, value, mod). """
        pass

    def __radd__(self, *args, **kwargs):  # real signature unknown
        """ Return value+self. """
        pass

    def __rand__(self, *args, **kwargs):  # real signature unknown
        """ Return value&amp;self. """
        pass

    def __rdivmod__(self, *args, **kwargs):  # real signature unknown
        """ Return divmod(value, self). """
        pass

    def __repr__(self, *args, **kwargs):  # real signature unknown
        """ Return repr(self). """
        pass

    def __rfloordiv__(self, *args, **kwargs):  # real signature unknown
        """ Return value//self. """
        pass

    def __rlshift__(self, *args, **kwargs):  # real signature unknown
        """ Return value&lt;&lt;self. """
        pass

    def __rmod__(self, *args, **kwargs):  # real signature unknown
        """ Return value%self. """
        pass

    def __rmul__(self, *args, **kwargs):  # real signature unknown
        """ Return value*self. """
        pass

    def __ror__(self, *args, **kwargs):  # real signature unknown
        """ Return value|self. """
        pass

    def __round__(self, *args, **kwargs):  # real signature unknown
        """
        Rounding an Integral returns itself.
        Rounding with an ndigits argument also returns an integer.
        """
        pass

    def __rpow__(self, *args, **kwargs):  # real signature unknown
        """ Return pow(value, self, mod). """
        pass

    def __rrshift__(self, *args, **kwargs):  # real signature unknown
        """ Return value&gt;&gt;self. """
        pass

    def __rshift__(self, *args, **kwargs):  # real signature unknown
        """ Return self&gt;&gt;value. """
        pass

    def __rsub__(self, *args, **kwargs):  # real signature unknown
        """ Return value-self. """
        pass

    def __rtruediv__(self, *args, **kwargs):  # real signature unknown
        """ Return value/self. """
        pass

    def __rxor__(self, *args, **kwargs):  # real signature unknown
        """ Return value^self. """
        pass

    def __sizeof__(self, *args, **kwargs):  # real signature unknown
        """ Returns size in memory, in bytes. """
        pass

    def __str__(self, *args, **kwargs):  # real signature unknown
        """ Return str(self). """
        pass

    def __sub__(self, *args, **kwargs):  # real signature unknown
        """ Return self-value. """
        pass

    def __truediv__(self, *args, **kwargs):  # real signature unknown
        """ Return self/value. """
        pass

    def __trunc__(self, *args, **kwargs):  # real signature unknown
        """ Truncating an Integral returns itself. """
        pass

    def __xor__(self, *args, **kwargs):  # real signature unknown
        """ Return self^value. """
        pass

    denominator = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """the denominator of a rational number in lowest terms"""

    imag = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """the imaginary part of a complex number"""

    numerator = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """the numerator of a rational number in lowest terms"""

    real = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """the real part of a complex number"""
</pre>
</div>
<p>　　</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>