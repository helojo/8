<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修2019 Python100道 面试 题，你会几道？' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>2019 Python100道 面试 题，你会几道？</center></div><div class='banquan'>原文出处:本文由博客园博主python学习者0提供。<br/>
原文连接:https://www.cnblogs.com/xxpythonxx/p/11722495.html</div><br>
    <h2 id="遇到过得反爬虫策略以及解决方法">0 遇到过得反爬虫策略以及解决方法?</h2>
<p>1.通过headers反爬虫<br />
2.基于用户行为的发爬虫：(同一IP短时间内访问的频率)<br />
3.动态网页反爬虫(通过ajax请求数据，或者通过JavaScript生成)<br />
4.对部分数据进行加密处理的(数据是乱码)</p>
<h3 id="解决方法">解决方法：</h3>
<p>对于基本网页的抓取可以自定义headers,添加headers的数据<br />
使用多个代理ip进行抓取或者设置抓取的频率降低一些，<br />
动态网页的可以使用selenium + phantomjs 进行抓取<br />
对部分数据进行加密的，可以使用selenium进行截图，使用python自带的pytesseract库进行识别，但是比较慢最直接的方法是找到加密的方法进行逆向推理。</p>
<h2 id="urllib-和-urllib2-的区别">1 urllib 和 urllib2 的区别？</h2>
<ul>
<li>urllib 和urllib2都是接受URL请求的相关模块，但是urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。urllib不可以伪装你的User-Agent字符串。</li>
<li>urllib提供urlencode()方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
</ul>
<h2 id="列举网络爬虫所用到的网络数据包解析包">2 列举网络爬虫所用到的网络数据包，解析包？</h2>
<ul>
<li>网络数据包 urllib、urllib2、requests</li>
<li>解析包 re、xpath、beautiful soup、lxml</li>
</ul>
<h2 id="简述一下爬虫的步骤">3 简述一下爬虫的步骤？</h2>
<ol>
<li>确定需求；</li>
<li>确定资源；</li>
<li>通过url获取网站的返回数据；</li>
<li>定位数据；</li>
<li>存储数据。</li>
</ol>
<h2 id="遇到反爬机制怎么处理">4 遇到反爬机制怎么处理？</h2>
<h2 id="反爬机制">反爬机制:</h2>
<p>headers方向<br />
判断User-Agent、判断Referer、判断Cookie。<br />
将浏览器的headers信息全部添加进去<br />
注意：Accept-Encoding；gzip,deflate需要注释掉</p>
<h2 id="常见的http方法有哪些">5 常见的HTTP方法有哪些？</h2>
<ul>
<li>GET：请求指定的页面信息，返回实体主体；</li>
<li>HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于捕获报头；</li>
<li>POST：向指定资源提交数据进行处理请求(比如表单提交或者上传文件)，。数据被包含在请求体中。</li>
<li>PUT:从客户端向服务端传送数据取代指定的文档的内容；</li>
<li>DELETE：请求删除指定的页面；</li>
<li>CONNNECT：HTTP1.1协议中预留给能够将连接方式改为管道方式的代理服务器；</li>
<li>OPTIONS:允许客户端查看服务器的性能；<br />
TRACE：回显服务器的请求，主要用于测试或者诊断。</li>
</ul>
<h2 id="说一说redis-scrapy中redis的作用">6 说一说redis-scrapy中redis的作用?</h2>
<p>它是将scrapy框架中Scheduler替换为redis数据库，实现队列管理共享。</p>
<h3 id="优点">优点：</h3>
<ol>
<li>可以充分利用多台机器的带宽；</li>
<li>可以充分利用多台机器的IP地址。</li>
</ol>
<h2 id="遇到的反爬虫策略以及解决方法">7 遇到的反爬虫策略以及解决方法?</h2>
<ol>
<li>通过headers反爬虫：自定义headers，添加网页中的headers数据。</li>
<li>基于用户行为的反爬虫(封IP)：可以使用多个代理IP爬取或者将爬取的频率降低。</li>
<li>动态网页反爬虫(JS或者Ajax请求数据)：动态网页可以使用 selenium + phantomjs 抓取。</li>
<li>对部分数据加密处理(数据乱码):找到加密方法进行逆向推理。</li>
</ol>
<h2 id="如果让你来防范网站爬虫你应该怎么来提高爬取的难度">8 如果让你来防范网站爬虫，你应该怎么来提高爬取的难度 ？</h2>
<ol>
<li>判断headers的User-Agent；</li>
<li>检测同一个IP的访问频率；</li>
<li>数据通过Ajax获取；</li>
<li>爬取行为是对页面的源文件爬取，如果要爬取静态网页的html代码，可以使用jquery去模仿写html。</li>
</ol>
<h2 id="scrapy分为几个组成部分分别有什么作用">9 scrapy分为几个组成部分？分别有什么作用？</h2>
<p>分为5个部分；Spiders(爬虫类)，Scrapy Engine(引擎),Scheduler(调度器),Downloader(下载器),Item Pipeline(处理管道)。</p>
<ul>
<li>Spiders:开发者自定义的一个类，用来解析网页并抓取指定url返回的内容。</li>
<li>Scrapy Engine:控制整个系统的数据处理流程，并进行事务处理的触发。</li>
<li>Scheduler：接收Engine发出的requests，并将这些requests放入到处理列队中，以便之后engine需要时再提供。</li>
<li>Download：抓取网页信息提供给engine，进而转发至Spiders。</li>
<li>Item Pipeline:负责处理Spiders类提取之后的数据。<br />
比如清理HTML数据、验证爬取的数据(检查item包含某些字段)、查重(并丢弃)、将爬取结果保存到数据库中</li>
</ul>
<h2 id="简述一下scrapy的基本流程">10 简述一下scrapy的基本流程?</h2>
<p><img src="./images/2019 Python100道 面试 题，你会几道？0.png" alt="在这里插入图片描述" /></p>
<h2 id="scrapy分为9个步骤">scrapy分为9个步骤：</h2>
<ol>
<li>Spiders需要初始的start_url或则函数stsrt_requests,会在内部生成Requests给Engine；</li>
<li>Engine将requests发送给Scheduler;</li>
<li>Engine从Scheduler那获取requests,交给Download下载；</li>
<li>在交给Dowmload过程中会经过Downloader Middlewares(经过process_request函数)；</li>
<li>Dowmloader下载页面后生成一个response，这个response会传给Engine，这个过程中又经过了Downloader Middlerwares(经过process_request函数)，在传送中出错的话经过process_exception函数；</li>
<li>Engine将从Downloader那传送过来的response发送给Spiders处理，这个过程经过Spiders Middlerwares(经过process_spider_input函数)；</li>
<li>Spiders处理这个response，返回Requests或者Item两个类型，传给Engine，这个过程又经过Spiders Middlewares(经过porcess_spider_output函数)；</li>
<li>Engine接收返回的信息，如果使Item，将它传给Items Pipeline中；如果是Requests,将它传给Scheduler，继续爬虫；</li>
<li>重复第三步，直至没有任何需要爬取的数据</li>
</ol>
<h2 id="python3.5语言中enumerate的意思是">11 python3.5语言中enumerate的意思是</h2>
<p>对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值<br />
enumerate多用于在for循环中得到计数</p>
<h2 id="你是否了解谷歌的无头浏览器">12 你是否了解谷歌的无头浏览器？</h2>
<p>无头浏览器即headless browser，是一种没有界面的浏览器。既然是浏览器那么浏览器该有的东西它都应该有，只是看不到界面而已。</p>
<p>Python中selenium模块中的PhantomJS即为无界面浏览器（无头浏览器）:是基于QtWebkit的无头浏览器。</p>
<h2 id="scrapy和scrapy-redis的区别">13 scrapy和scrapy-redis的区别？</h2>
<p>scrapy是一个爬虫通用框架，但不支持分布式，scrapy-redis是为了更方便的实现scrapy分布式爬虫，而提供了一些以redis为基础的组件</p>
<h2 id="为什么会选择redis数据库">为什么会选择redis数据库？</h2>
<p>因为redis支持主从同步，而且数据都是缓存在内存中，所以基于redis的分布式爬虫，对请求和数据的高频读取效率非常高</p>
<h2 id="什么是主从同步">什么是主从同步？</h2>
<p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave），当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态</p>
<h2 id="scrapy的优缺点为什么要选择scrapy框架">14 scrapy的优缺点？为什么要选择scrapy框架？</h2>
<h3 id="优点-1">优点：</h3>
<p>采取可读性更强的xpath代替正则 强大的统计和log系统 同时在不同的url上爬行 支持shell方式，方便独立调试 写middleware,方便写一些统一的过滤器 通过管道的方式存入数据库</p>
<h3 id="缺点">缺点：</h3>
<p>基于python爬虫框架，扩展性比较差，基于twisted框架，运行中exception是不会干掉reactor，并且异步框架出错后是不会停掉其他任务的，数据出错后难以察觉</p>
<h2 id="scrapy和requests的使用情况">15 scrapy和requests的使用情况？</h2>
<p>requests 是 polling 方式的，会被网络阻塞，不适合爬取大量数据</p>
<p>scapy 底层是异步框架 twisted ，并发是最大优势</p>
<h2 id="描述一下scrapy框架的运行机制">16 描述一下scrapy框架的运行机制？</h2>
<p>从start_urls里面获取第一批url发送请求，请求由请求引擎给调度器入请求对列，获取完毕后，调度器将请求对列交给下载器去获取请求对应的响应资源，并将响应交给自己编写的解析方法做提取处理，如果提取出需要的数据，则交给管道处理，如果提取出url，则继续执行之前的步骤，直到多列里没有请求，程序结束。</p>
<h2 id="写爬虫使用多进程好还是用多线程好">17 写爬虫使用多进程好，还是用多线程好？</h2>
<p>IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。在实际的数据采集过程中，既考虑网速和响应的问题，也需要考虑自身机器的硬件情况，来设置多进程或多线程</p>
<h2 id="常见的反爬虫和应对方法">18 常见的反爬虫和应对方法？</h2>
<ol>
<li>基于用户行为，同一个ip段时间多次访问同一页面 利用代理ip，构建ip池</li>
<li>请求头里的user-agent 构建user-agent池（操作系统、浏览器不同，模拟不同用户）</li>
<li>动态加载（抓到的数据和浏览器显示的不一样），js渲染 模拟ajax请求，返回json形式的数据</li>
<li>selenium / webdriver 模拟浏览器加载</li>
<li>对抓到的数据进行分析</li>
<li>加密参数字段 会话跟踪【cookie】 防盗链设置【Referer</li>
</ol>
<h2 id="分布式爬虫主要解决什么问题">19 分布式爬虫主要解决什么问题？</h2>
<p>面对海量待抓取网页，只有采用分布式架构，才有可能在较短时间内完成一轮抓取工作。</p>
<p>它的开发效率是比较快而且简单的。</p>
<h2 id="如何提高爬取效率">20 如何提高爬取效率？</h2>
<p>爬虫下载慢主要原因是阻塞等待发往网站的请求和网站返回</p>
<pre><code><code>    1，采用异步与多线程，扩大电脑的cpu利用率；

    2，采用消息队列模式

    3，提高带宽</code></pre>
<h2 id="说说什么是爬虫协议">21 说说什么是爬虫协议？</h2>
<p>Robots协议（也称为爬虫协议、爬虫规则、机器人协议等）也就是robots.txt，网站通过robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</p>
<p>Robots协议是网站国际互联网界通行的道德规范，其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯。因其不是命令，故需要搜索引擎自觉遵守。</p>
<h2 id="如果对方网站反爬取封ip了怎么办">22 如果对方网站反爬取，封IP了怎么办？</h2>
<ol>
<li>放慢抓取熟速度，减小对目标网站造成的压力，但是这样会减少单位时间内的数据抓取量</li>
<li>使用代理IP（免费的可能不稳定，收费的可能不划算）</li>
</ol>
<h2 id="有一个jsonline格式的文件file">23 有一个jsonline格式的文件file</h2>
<pre class="python"><code>#Python学习交流QQ群：857662006 寻找有志同道合的小伙伴
def get_lines():
    with open(&#39;file.txt&#39;,&#39;rb&#39;) as f:
        return f.readlines()

if __name__ == &#39;__main__&#39;:
    for e in get_lines():
        process(e) # 处理每一行数据</code></pre>
<p>现在要处理一个大小为10G的文件，但是内存只有4G，如果在只修改get_lines 函数而其他代码保持不变的情况下，应该如何实现？需要考虑的问题都有那些？</p>
<pre class="python"><code>def get_lines():
    with open(&#39;file.txt&#39;,&#39;rb&#39;) as f:
        for i in f:
            yield i</code></pre>
<p>Pandaaaa906提供的方法</p>
<pre class="python"><code>from mmap import mmap


def get_lines(fp):
    with open(fp,&quot;r+&quot;) as f:
        m = mmap(f.fileno(), 0)
        tmp = 0
        for i, char in enumerate(m):
            if char==b&quot;\n&quot;:
                yield m[tmp:i+1].decode()
                tmp = i+1

if __name__==&quot;__main__&quot;:
    for i in get_lines(&quot;fp_some_huge_file&quot;):
        print(i)</code></pre>
<p>要考虑的问题有：内存只有4G无法一次性读入10G文件，需要分批读入分批读入数据要记录每次读入数据的位置。分批每次读取数据的大小，太小会在读取操作花费过多时间。<br />
https://stackoverflow.com/questions/30294146/python-fastest-way-to-process-large-file</p>
<h2 id="补充缺失的代码">24 补充缺失的代码</h2>
<pre class="python"><code>def print_directory_contents(sPath):
&quot;&quot;&quot;
这个函数接收文件夹的名称作为输入参数
返回该文件夹中文件的路径
以及其包含文件夹中文件的路径
&quot;&quot;&quot;
import os
for s_child in os.listdir(s_path):
    s_child_path = os.path.join(s_path, s_child)
    if os.path.isdir(s_child_path):
        print_directory_contents(s_child_path)
    else:
        print(s_child_path)</code></pre>
<h2 id="输入日期-判断这一天是这一年的第几天">25 输入日期， 判断这一天是这一年的第几天？</h2>
<pre class="python"><code>import datetime
def dayofyear():
    year = input(&quot;请输入年份: &quot;)
    month = input(&quot;请输入月份: &quot;)
    day = input(&quot;请输入天: &quot;)
    date1 = datetime.date(year=int(year),month=int(month),day=int(day))
    date2 = datetime.date(year=int(year),month=1,day=1)
    return (date1-date2).days+1</code></pre>
<h2 id="打乱一个排好序的list对象alist">26 打乱一个排好序的list对象alist？</h2>
<pre class="python"><code>import random
alist = [1,2,3,4,5]
random.shuffle(alist)
print(alist)</code></pre>
<h2 id="现有字典-d-a24g52i12k33请按value值进行排序">27 现有字典 d= {'a':24,'g':52,'i':12,'k':33}请按value值进行排序?</h2>
<pre class="python"><code>sorted(d.items(),key=lambda x:x[1])</code></pre>
<h2 id="字典推导式">28 字典推导式</h2>
<pre class="python"><code>d = {key:value for (key,value) in iterable}</code></pre>
<h2 id="请反转字符串-astr">29 请反转字符串 &quot;aStr&quot;?</h2>
<pre class="python"><code>print(&quot;aStr&quot;[::-1])</code></pre>
<h2 id="将字符串-k1-k12k23k34处理成字典">30 将字符串 &quot;k:1 |k1:2|k2:3|k3:4&quot;，处理成字典</h2>
<pre class="python"><code>str1 = &quot;k:1|k1:2|k2:3|k3:4&quot;
def str2dict(str1):
    dict1 = {}
    for iterms in str1.split(&#39;|&#39;):
        key,value = iterms.split(&#39;:&#39;)
        dict1[key] = value
    return dict1
#字典推导式
d = {k:int(v) for t in str1.split(&quot;|&quot;) for k, v in (t.split(&quot;:&quot;), )}</code></pre>
<h2 id="请按alist中元素的age由大到小排序">31 请按alist中元素的age由大到小排序</h2>
<pre class="python"><code>alist = [{&#39;name&#39;:&#39;a&#39;,&#39;age&#39;:20},{&#39;name&#39;:&#39;b&#39;,&#39;age&#39;:30},{&#39;name&#39;:&#39;c&#39;,&#39;age&#39;:25}]
def sort_by_age(list1):
    return sorted(alist,key=lambda x:x[&#39;age&#39;],reverse=True)</code></pre>
<h2 id="下面代码的输出结果将是什么">32 下面代码的输出结果将是什么？</h2>
<pre class="python"><code>list = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]
print(list[10:])</code></pre>
<p>代码将输出[],不会产生IndexError错误，就像所期望的那样，尝试用超出成员的个数的index来获取某个列表的成员。例如，尝试获取list[10]和之后的成员，会导致IndexError。然而，尝试获取列表的切片，开始的index超过了成员个数不会产生IndexError，而是仅仅返回一个空列表。这成为特别让人恶心的疑难杂症，因为运行的时候没有错误产生，导致Bug很难被追踪到。</p>
<h2 id="写一个列表生成式产生一个公差为11的等差数列">33 写一个列表生成式，产生一个公差为11的等差数列</h2>
<pre class="python"><code>print([x*11 for x in range(10)])</code></pre>
<h2 id="给定两个列表怎么找出他们相同的元素和不同的元素">34 给定两个列表，怎么找出他们相同的元素和不同的元素？</h2>
<pre class="python"><code>list1 = [1,2,3]
list2 = [3,4,5]
set1 = set(list1)
set2 = set(list2)
print(set1 &amp; set2)
print(set1 ^ set2)</code></pre>
<h2 id="请写出一段python代码实现删除list里面的重复元素">35 请写出一段python代码实现删除list里面的重复元素？</h2>
<pre class="python"><code>l1 = [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;c&#39;,&#39;a&#39;,&#39;a&#39;]
l2 = list(set(l1))
print(l2)</code></pre>
<p>用list类的sort方法:</p>
<pre class="python"><code>l1 = [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;c&#39;,&#39;a&#39;,&#39;a&#39;]
l2 = list(set(l1))
l2.sort(key=l1.index)
print(l2)</code></pre>
<p>也可以这样写:</p>
<pre class="python"><code>l1 = [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;c&#39;,&#39;a&#39;,&#39;a&#39;]
l2 = sorted(set(l1),key=l1.index)
print(l2)</code></pre>
<p>也可以用遍历：</p>
<pre class="python"><code>l1 = [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;c&#39;,&#39;a&#39;,&#39;a&#39;]
l2 = []
for i in l1:
    if not i in l2:
        l2.append(i)
print(l2)</code></pre>
<h2 id="给定两个list-ab-请用找出ab中相同与不同的元素">36 给定两个list A，B ,请用找出A，B中相同与不同的元素</h2>
<pre class="python"><code>A,B 中相同元素：print(set(A)&amp;set(B))
A,B 中不同元素:  print(set(A)^set(B))</code></pre>
<h2 id="python新式类和经典类的区别">37 python新式类和经典类的区别？</h2>
<p>a. 在python里凡是继承了object的类，都是新式类</p>
<p>b. Python3里只有新式类</p>
<p>c. Python2里面继承object的是新式类，没有写父类的是经典类</p>
<p>d. 经典类目前在Python里基本没有应用</p>
<h2 id="python中内置的数据结构有几种">38 python中内置的数据结构有几种？</h2>
<p>a. 整型 int、 长整型 long、浮点型 float、 复数 complex</p>
<p>b. 字符串 str、 列表 list、 元祖 tuple</p>
<p>c. 字典 dict 、 集合 set</p>
<p>d. Python3 中没有 long，只有无限精度的 int</p>
<h2 id="python如何实现单例模式请写出两种实现方式">39 python如何实现单例模式?请写出两种实现方式?</h2>
<p>第一种方法:使用装饰器</p>
<pre class="python"><code>#Python学习交流QQ群：857662006
def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper


@singleton
class Foo(object):
    pass
foo1 = Foo()
foo2 = Foo()
print(foo1 is foo2)  # True</code></pre>
<p>第二种方法：使用基类<br />
New 是真正创建实例对象的方法，所以重写基类的new 方法，以此保证创建对象的时候只生成一个实例</p>
<pre class="python"><code>class Singleton(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, &#39;_instance&#39;):
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance


class Foo(Singleton):
    pass

foo1 = Foo()
foo2 = Foo()

print(foo1 is foo2)  # True</code></pre>
<p>第三种方法：元类，元类是用于创建类对象的类，类对象创建实例对象时一定要调用call方法，因此在调用call时候保证始终只创建一个实例即可，type是python的元类</p>
<pre class="python"><code>class Singleton(type):
    def __call__(cls, *args, **kwargs):
        if not hasattr(cls, &#39;_instance&#39;):
            cls._instance = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instance


# Python2
class Foo(object):
    __metaclass__ = Singleton

# Python3
class Foo(metaclass=Singleton):
    pass

foo1 = Foo()
foo2 = Foo()
print(foo1 is foo2)  # True</code></pre>
<h2 id="反转一个整数例如-123-----321">40 反转一个整数，例如-123 --&gt; -321</h2>
<pre class="python"><code>class Solution(object):
    def reverse(self,x):
        if -10&lt;x&lt;10:
            return x
        str_x = str(x)
        if str_x[0] !=&quot;-&quot;:
            str_x = str_x[::-1]
            x = int(str_x)
        else:
            str_x = str_x[1:][::-1]
            x = int(str_x)
            x = -x
        return x if -2147483648&lt;x&lt;2147483647 else 0
if __name__ == &#39;__main__&#39;:
    s = Solution()
    reverse_int = s.reverse(-120)
    print(reverse_int)</code></pre>
<h2 id="设计实现遍历目录与子目录抓取.pyc文件">41 设计实现遍历目录与子目录，抓取.pyc文件?</h2>
<p>第一种方法：</p>
<pre class="python"><code>import os

def get_files(dir,suffix):
    res = []
    for root,dirs,files in os.walk(dir):
        for filename in files:
            name,suf = os.path.splitext(filename)
            if suf == suffix:
                res.append(os.path.join(root,filename))

    print(res)

get_files(&quot;./&quot;,&#39;.pyc&#39;)</code></pre>
<p>第二种方法：</p>
<pre class="python"><code>import os

def pick(obj):
    if ob.endswith(&quot;.pyc&quot;):
        print(obj)

def scan_path(ph):
    file_list = os.listdir(ph)
    for obj in file_list:
        if os.path.isfile(obj):
    pick(obj)
        elif os.path.isdir(obj):
            scan_path(obj)

if __name__==&#39;__main__&#39;:
    path = input(&#39;输入目录&#39;)
    scan_path(path)</code></pre>
<p>第三种方法</p>
<pre class="python"><code>from glob import iglob


def func(fp, postfix):
    for i in iglob(f&quot;{fp}/**/*{postfix}&quot;, recursive=True):
        print(i)

if __name__ == &quot;__main__&quot;:
    postfix = &quot;.pyc&quot;
    func(&quot;K:\Python_script&quot;, postfix)</code></pre>
<h2 id="python-遍历列表时删除元素的正确做法">42 Python-遍历列表时删除元素的正确做法</h2>
<p>遍历在新在列表操作，删除时在原来的列表操作</p>
<pre class="python"><code>a = [1,2,3,4,5,6,7,8]
print(id(a))
print(id(a[:]))
for i in a[:]:
    if i&gt;5:
        pass
    else:
        a.remove(i)
    print(a)
print(&#39;-----------&#39;)
print(id(a))
#filter
a=[1,2,3,4,5,6,7,8]
b = filter(lambda x: x&gt;5,a)
print(list(b))</code></pre>
<p>列表解析</p>
<pre class="python"><code>a=[1,2,3,4,5,6,7,8]
b = [i for i in a if i&gt;5]
print(b)</code></pre>
<p>倒序删除<br />
因为列表总是‘向前移’，所以可以倒序遍历，即使后面的元素被修改了，还没有被遍历的元素和其坐标还是保持不变的</p>
<pre class="python"><code>a=[1,2,3,4,5,6,7,8]
print(id(a))
for i in range(len(a)-1,-1,-1):
    if a[i]&gt;5:
        pass
    else:
        a.remove(a[i])
print(id(a))
print(&#39;-----------&#39;)
print(a)</code></pre>
<h2 id="字符串的操作题目">43 字符串的操作题目</h2>
<p>全字母短句 PANGRAM 是包含所有英文字母的句子，比如：A QUICK BROWN FOX JUMPS OVER THE LAZY DOG. 定义并实现一个方法 get_missing_letter, 传入一个字符串采纳数，返回参数字符串变成一个 PANGRAM 中所缺失的字符。应该忽略传入字符串参数中的大小写，返回应该都是小写字符并按字母顺序排序（请忽略所有非 ACSII 字符）</p>
<p><strong>下面示例是用来解释，双引号不需要考虑:</strong></p>
<p>(0)输入: &quot;A quick brown for jumps over the lazy dog&quot;</p>
<p>返回：&quot;&quot;</p>
<p>(1)输入: &quot;A slow yellow fox crawls under the proactive dog&quot;</p>
<p>返回: &quot;bjkmqz&quot;</p>
<p>(2)输入: &quot;Lions, and tigers, and bears, oh my!&quot;</p>
<p>返回: &quot;cfjkpquvwxz&quot;</p>
<p>(3)输入: &quot;&quot;</p>
<p>返回：&quot;abcdefghijklmnopqrstuvwxyz&quot;</p>
<pre class="python"><code>
def get_missing_letter(a):
    s1 = set(&quot;abcdefghijklmnopqrstuvwxyz&quot;)
    s2 = set(a)
    ret = &quot;&quot;.join(sorted(s1-s2))
    return ret

print(get_missing_letter(&quot;python&quot;))</code></pre>
<h2 id="可变类型和不可变类型">44 可变类型和不可变类型</h2>
<p>1,可变类型有list,dict.不可变类型有string，number,tuple.</p>
<p>2,当进行修改操作时，可变类型传递的是内存中的地址，也就是说，直接修改内存中的值，并没有开辟新的内存。</p>
<p>3,不可变类型被改变时，并没有改变原内存地址中的值，而是开辟一块新的内存，将原地址中的值复制过去，对这块新开辟的内存中的值进行操作。</p>
<h2 id="is和有什么区别">45 is和==有什么区别？</h2>
<p>is：比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象。是否指向同一个内存地址</p>
<p>== ：比较的两个对象的内容/值是否相等，默认会调用对象的eq()方法</p>
<h2 id="求出列表所有奇数并构造新列表">46 求出列表所有奇数并构造新列表</h2>
<pre class="python"><code>a = [1,2,3,4,5,6,7,8,9,10]
res = [ i for i in a if i%2==1]
print(res)</code></pre>
<h2 id="用一行python代码写出12310248">47 用一行python代码写出1+2+3+10248</h2>
<pre class="python"><code>from functools import reduce
#1.使用sum内置求和函数
num = sum([1,2,3,10248])
print(num)
#2.reduce 函数
num1 = reduce(lambda x,y :x+y,[1,2,3,10248])
print(num1)</code></pre>
<h2 id="python中变量的作用域变量查找顺序">48 Python中变量的作用域？（变量查找顺序)</h2>
<p>函数作用域的LEGB顺序</p>
<p>1.什么是LEGB?</p>
<p>L：local 函数内部作用域</p>
<p>E: enclosing 函数内部与内嵌函数之间</p>
<p>G: global 全局作用域</p>
<p>B：build-in 内置作用</p>
<p>python在函数里面的查找分为4种，称之为LEGB，也正是按照这是顺序来查找的</p>
<h2 id="字符串-123-转换成-123不使用内置api例如-int">49 字符串 <code>&quot;123&quot;</code> 转换成 <code>123</code>，不使用内置api，例如 <code>int()</code></h2>
<p>方法一：利用 <code>str</code> 函数</p>
<pre class="python"><code>def atoi(s):
    num = 0
    for v in s:
        for j in range(10):
            if v == str(j):
                num = num * 10 + j
    return num</code></pre>
<p>方法二：利用 <code>ord</code> 函数</p>
<pre class="python"><code>def atoi(s):
    num = 0
    for v in s:
        num = num * 10 + ord(v) - ord(&#39;0&#39;)
    return num</code></pre>
<p>方法三: 利用 <code>eval</code> 函数</p>
<pre class="python"><code>def atoi(s):
    num = 0
    for v in s:
        t = &quot;%s * 1&quot; % v
        n = eval(t)
        num = num * 10 + n
    return num</code></pre>
<p>方法四: 结合方法二，使用 <code>reduce</code>，一行解决</p>
<pre class="python"><code>from functools import reduce
def atoi(s):
    return reduce(lambda num, v: num * 10 + ord(v) - ord(&#39;0&#39;), s, 0)</code></pre>
<h2 id="given-an-array-of-integers">50 Given an array of integers</h2>
<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例:给定nums = [2,7,11,15],target=9 因为 nums[0]+nums[1] = 2+7 =9,所以返回[0,1]</p>
<pre class="python"><code>class Solution:
    def twoSum(self,nums,target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        d = {}
        size = 0
        while size &lt; len(nums):
            if target-nums[size] in d:
                if d[target-nums[size]] &lt;size:
                    return [d[target-nums[size]],size]
                else:
                    d[nums[size]] = size
                size = size +1
solution = Solution()
list = [2,7,11,15]
target = 9
nums = solution.twoSum(list,target)
print(nums)</code></pre>
<p>给列表中的字典排序：假设有如下list对象，alist=[{&quot;name&quot;:&quot;a&quot;,&quot;age&quot;:20},{&quot;name&quot;:&quot;b&quot;,&quot;age&quot;:30},{&quot;name&quot;:&quot;c&quot;,&quot;age&quot;:25}],将alist中的元素按照age从大到小排序 alist=[{&quot;name&quot;:&quot;a&quot;,&quot;age&quot;:20},{&quot;name&quot;:&quot;b&quot;,&quot;age&quot;:30},{&quot;name&quot;:&quot;c&quot;,&quot;age&quot;:25}]</p>
<pre class="python"><code>alist_sort = sorted(alist,key=lambda e: e.__getitem__(&#39;age&#39;),reverse=True)</code></pre>
<h2 id="python代码实现删除一个list里面的重复元素">51 python代码实现删除一个list里面的重复元素</h2>
<pre class="python"><code>def distFunc1(a):
    &quot;&quot;&quot;使用集合去重&quot;&quot;&quot;
    a = list(set(a))
    print(a)

def distFunc2(a):
    &quot;&quot;&quot;将一个列表的数据取出放到另一个列表中，中间作判断&quot;&quot;&quot;
    list = []
    for i in a:
        if i not in list:
            list.append(i)
    #如果需要排序的话用sort
    list.sort()
    print(list)

def distFunc3(a):
    &quot;&quot;&quot;使用字典&quot;&quot;&quot;
    b = {}
    b = b.fromkeys(a)
    c = list(b.keys())
    print(c)

if __name__ == &quot;__main__&quot;:
    a = [1,2,4,2,4,5,7,10,5,5,7,8,9,0,3]
    distFunc1(a)
    distFunc2(a)
    distFunc3(a)</code></pre>
<h2 id="统计一个文本中单词频次最高的10个单词">52 统计一个文本中单词频次最高的10个单词？</h2>
<pre class="python"><code>import re

# 方法一
def test(filepath):

    distone = {}

    with open(filepath) as f:
        for line in f:
            line = re.sub(&quot;\W+&quot;, &quot; &quot;, line)
            lineone = line.split()
            for keyone in lineone:
                if not distone.get(keyone):
                    distone[keyone] = 1
                else:
                    distone[keyone] += 1
    num_ten = sorted(distone.items(), key=lambda x:x[1], reverse=True)[:10]
    num_ten =[x[0] for x in num_ten]
    return num_ten


# 方法二 
# 使用 built-in 的 Counter 里面的 most_common
import re
from collections import Counter


def test2(filepath):
    with open(filepath) as f:
        return list(map(lambda c: c[0], Counter(re.sub(&quot;\W+&quot;, &quot; &quot;, f.read()).split()).most_common(10)))</code></pre>
<h2 id="请写出一个函数满足以下条件">53 请写出一个函数满足以下条件</h2>
<p>该函数的输入是一个仅包含数字的list,输出一个新的list，其中每一个元素要满足以下条件：</p>
<p>1、该元素是偶数</p>
<p>2、该元素在原list中是在偶数的位置(index是偶数)</p>
<pre class="python"><code>def num_list(num):
    return [i for i in num if i %2 ==0 and num.index(i)%2==0]

num = [0,1,2,3,4,5,6,7,8,9,10]
result = num_list(num)
print(result)</code></pre>
<h2 id="使用单一的列表生成式来产生一个新的列表">54 使用单一的列表生成式来产生一个新的列表</h2>
<p>该列表只包含满足以下条件的值，元素为原始列表中偶数切片</p>
<pre class="python"><code>list_data = [1,2,5,8,10,3,18,6,20]
res = [x for x in list_data[::2] if x %2 ==0]
print(res)</code></pre>
<h2 id="用一行代码生成149162536496481100">55 用一行代码生成[1,4,9,16,25,36,49,64,81,100]</h2>
<pre class="python"><code>[x * x for x in range(1,11)]</code></pre>
<h2 id="输入某年某月某日判断这一天是这一年的第几天">56 输入某年某月某日，判断这一天是这一年的第几天？</h2>
<pre class="python"><code>import datetime

y = int(input(&quot;请输入4位数字的年份:&quot;))
m = int(input(&quot;请输入月份:&quot;))
d = int(input(&quot;请输入是哪一天&quot;))

targetDay = datetime.date(y,m,d)
dayCount = targetDay - datetime.date(targetDay.year -1,12,31)
print(&quot;%s是 %s年的第%s天。&quot;%(targetDay,y,dayCount.days))</code></pre>
<h2 id="两个有序列表l1l2对这两个列表进行合并不可使用extend">57 两个有序列表，l1,l2，对这两个列表进行合并不可使用extend</h2>
<pre class="python"><code>def loop_merge_sort(l1,l2):
    tmp = []
    while len(l1)&gt;0 and len(l2)&gt;0:
        if l1[0] &lt;l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
    while len(l1)&gt;0:
        tmp.append(l1[0])
        del l1[0]
    while len(l2)&gt;0:
        tmp.append(l2[0])
        del l2[0]
    return tmp</code></pre>
<h2 id="给定一个任意长度数组实现一个函数">58 给定一个任意长度数组，实现一个函数</h2>
<p>让所有奇数都在偶数前面，而且奇数升序排列，偶数降序排序，如字符串'1982376455',变成'1355798642'</p>
<pre class="python"><code># 方法一
def func1(l):
    if isinstance(l, str):
        l = [int(i) for i in l]
    l.sort(reverse=True)
    for i in range(len(l)):
        if l[i] % 2 &gt; 0:
            l.insert(0, l.pop(i))
    print(&#39;&#39;.join(str(e) for e in l))

# 方法二
def func2(l):
    print(&quot;&quot;.join(sorted(l, key=lambda x: int(x) % 2 == 0 and 20 - int(x) or int(x))))</code></pre>
<h2 id="写一个函数找出一个整数数组中第二大的数">59 写一个函数找出一个整数数组中，第二大的数</h2>
<pre class="python"><code>#Python学习交流QQ群：857662006 
def find_second_large_num(num_list):
    &quot;&quot;&quot;
    找出数组第2大的数字
    &quot;&quot;&quot;
    # 方法一
    # 直接排序，输出倒数第二个数即可
    tmp_list = sorted(num_list)
    print(&quot;方法一\nSecond_large_num is :&quot;, tmp_list[-2])

    # 方法二
    # 设置两个标志位一个存储最大数一个存储次大数
    # two 存储次大值，one 存储最大值，遍历一次数组即可，先判断是否大于 one，若大于将 one 的值给 two，将 num_list[i] 的值给 one，否则比较是否大于two，若大于直接将 num_list[i] 的值给two，否则pass
    one = num_list[0]
    two = num_list[0]
    for i in range(1, len(num_list)):
        if num_list[i] &gt; one:
            two = one
            one = num_list[i]
        elif num_list[i] &gt; two:
            two = num_list[i]
    print(&quot;方法二\nSecond_large_num is :&quot;, two)

    # 方法三
    # 用 reduce 与逻辑符号 (and, or)
    # 基本思路与方法二一样，但是不需要用 if 进行判断。
    from functools import reduce
    num = reduce(lambda ot, x: ot[1] &lt; x and (ot[1], x) or ot[0] &lt; x and (x, ot[1]) or ot, num_list, (0, 0))[0]
    print(&quot;方法三\nSecond_large_num is :&quot;, num)


if __name__ == &#39;__main___&#39;:
    num_list = [34, 11, 23, 56, 78, 0, 9, 12, 3, 7, 5]
    find_second_large_num(num_list)</code></pre>
<h2 id="阅读一下代码他们的输出结果是什么">60 阅读一下代码他们的输出结果是什么？</h2>
<pre class="python"><code>def multi():
    return [lambda x : i*x for i in range(4)]
print([m(3) for m in multi()])</code></pre>
<p>正确答案是[9,9,9,9]，而不是[0,3,6,9]产生的原因是Python的闭包的后期绑定导致的，这意味着在闭包中的变量是在内部函数被调用的时候被查找的，因为，最后函数被调用的时候，for循环已经完成, i 的值最后是3,因此每一个返回值的i都是3,所以最后的结果是[9,9,9,9]</p>
<h2 id="统计一段字符串中字符出现的次数">61 统计一段字符串中字符出现的次数</h2>
<pre class="python"><code># 方法一
def count_str(str_data):
    &quot;&quot;&quot;定义一个字符出现次数的函数&quot;&quot;&quot;
    dict_str = {} 
    for i in str_data:
        dict_str[i] = dict_str.get(i, 0) + 1
    return dict_str
dict_str = count_str(&quot;AAABBCCAC&quot;)
str_count_data = &quot;&quot;
for k, v in dict_str.items():
    str_count_data += k + str(v)
print(str_count_data)

# 方法二
from collections import Counter

print(&quot;&quot;.join(map(lambda x: x[0] + str(x[1]), Counter(&quot;AAABBCCAC&quot;).most_common())))</code></pre>
<h2 id="python中类方法类实例方法静态方法有何区别">62 Python中类方法、类实例方法、静态方法有何区别？</h2>
<p>类方法: 是类对象的方法，在定义时需要在上方使用 @classmethod 进行装饰,形参为cls，表示类对象，类对象和实例对象都可调用</p>
<p>类实例方法: 是类实例化对象的方法,只有实例对象可以调用，形参为self,指代对象本身;</p>
<p>静态方法: 是一个任意函数，在其上方使用 @staticmethod 进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系</p>
<h2 id="遍历一个object的所有属性并print每一个属性名">63 遍历一个object的所有属性，并print每一个属性名？</h2>
<pre class="python"><code>class Car:
    def __init__(self,name,loss): # loss [价格，油耗，公里数]
        self.name = name
        self.loss = loss

    def getName(self):
        return self.name

    def getPrice(self):
        # 获取汽车价格
        return self.loss[0]

    def getLoss(self):
        # 获取汽车损耗值
        return self.loss[1] * self.loss[2]

Bmw = Car(&quot;宝马&quot;,[60,9,500]) # 实例化一个宝马车对象
print(getattr(Bmw,&quot;name&quot;)) # 使用getattr()传入对象名字,属性值。
print(dir(Bmw)) # 获Bmw所有的属性和方法</code></pre>
<h2 id="写一个类并让它尽可能多的支持操作符">64 写一个类，并让它尽可能多的支持操作符?</h2>
<pre class="python"><code>class Array:
    __list = []

    def __init__(self):
        print &quot;constructor&quot;

    def __del__(self):
        print &quot;destruct&quot;

    def __str__(self):
        return &quot;this self-defined array class&quot;

    def __getitem__(self,key):
        return self.__list[key]

    def __len__(self):
        return len(self.__list)

    def Add(self,value):
        self.__list.append(value)

    def Remove(self,index):
        del self.__list[index]

    def DisplayItems(self):
        print &quot;show all items---&quot;
        for item in self.__list:
            print item</code></pre>
<h2 id="关于python内存管理下列说法错误的是-b">65 关于Python内存管理,下列说法错误的是 B</h2>
<p>A,变量不必事先声明 B,变量无须先创建和赋值而直接使用</p>
<p>C,变量无须指定类型 D,可以使用del释放资源</p>
<h2 id="python的内存管理机制及调优手段">66 Python的内存管理机制及调优手段？</h2>
<p>内存管理机制: 引用计数、垃圾回收、内存池</p>
<p>引用计数：引用计数是一种非常高效的内存管理手段，当一个Python对象被引用时其引用计数增加1,</p>
<p>当其不再被一个变量引用时则计数减1,当引用计数等于0时对象被删除。弱引用不会增加引用计数</p>
<p>垃圾回收：</p>
<p>1.引用计数</p>
<p>引用计数也是一种垃圾收集机制，而且也是一种最直观、最简单的垃圾收集技术。当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1，如果引用被删除，对象的引用计数为0,那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了。</p>
<p>2.标记清除</p>
<p>调优手段</p>
<p>1.手动垃圾回收</p>
<p>2.调高垃圾回收阈值</p>
<p>3.避免循环引用</p>
<h2 id="内存泄露是什么如何避免">67 内存泄露是什么？如何避免？</h2>
<p><strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
<p>有<code>__del__()</code>函数的对象间的循环引用是导致内存泄露的主凶。不使用一个对象时使用: del object 来删除一个对象的引用计数就可以有效防止内存泄露问题。</p>
<p>通过Python扩展模块gc 来查看不能回收的对象的详细信息。</p>
<p>可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为0来判断是否内存泄露</p>
<h2 id="python常见的列表推导式">68 python常见的列表推导式？</h2>
<p>[表达式 for 变量 in 列表] 或者 [表达式 for 变量 in 列表 if 条件]</p>
<h2 id="简述readreadlinereadlines的区别">69 简述read、readline、readlines的区别？</h2>
<p>read 读取整个文件</p>
<p>readline 读取下一行</p>
<p>readlines 读取整个文件到一个迭代器以供我们遍历</p>
<h2 id="什么是hash散列函数">70 什么是Hash（散列函数）？</h2>
<p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表</p>
<h2 id="python函数重载机制">71 python函数重载机制？</h2>
<p>函数重载主要是为了解决两个问题。<br />
1。可变参数类型。<br />
2。可变参数个数。</p>
<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>
<p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>
<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p>
<p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p>
<h2 id="手写一个判断时间的装饰器">72 手写一个判断时间的装饰器</h2>
<pre class="python"><code>import datetime


class TimeException(Exception):
    def __init__(self, exception_info):
        super().__init__()
        self.info = exception_info

    def __str__(self):
        return self.info


def timecheck(func):
    def wrapper(*args, **kwargs):
        if datetime.datetime.now().year == 2019:
            func(*args, **kwargs)
        else:
            raise TimeException(&quot;函数已过时&quot;)

    return wrapper


@timecheck
def test(name):
    print(&quot;Hello {}, 2019 Happy&quot;.format(name))


if __name__ == &quot;__main__&quot;:
    test(&quot;backbp&quot;)</code></pre>
<h2 id="使用python内置的filter方法来过滤">73 使用Python内置的filter()方法来过滤？</h2>
<pre class="python"><code>list(filter(lambda x: x % 2 == 0, range(10)))</code></pre>
<h2 id="编写函数的4个原则">74 编写函数的4个原则</h2>
<p>1.函数设计要尽量短小</p>
<p>2.函数声明要做到合理、简单、易于使用</p>
<p>3.函数参数设计应该考虑向下兼容</p>
<p>4.一个函数只做一件事情，尽量保证函数语句粒度的一致性</p>
<h2 id="函数调用参数的传递方式是值传递还是引用传递">75 函数调用参数的传递方式是值传递还是引用传递？</h2>
<p>Python的参数传递有：位置参数、默认参数、可变参数、关键字参数。</p>
<p>函数的传值到底是值传递还是引用传递、要分情况：</p>
<p>不可变参数用值传递：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。</p>
<p>可变参数是引用传递：比如像列表，字典这样的对象是通过引用传递、和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。</p>
<h2 id="如何在function里面设置一个全局变量">76 如何在function里面设置一个全局变量</h2>
<pre class="python"><code>globals() # 返回包含当前作用余全局变量的字典。
global 变量 设置使用全局变量</code></pre>
<h2 id="对缺省参数的理解">77 对缺省参数的理解 ？</h2>
<p>缺省参数指在调用函数的时候没有传入参数的情况下，调用默认的参数，在调用函数的同时赋值时，所传入的参数会替代默认参数。</p>
<p>*args是不定长参数，它可以表示输入参数是不确定的，可以是任意多个。</p>
<p>**kwargs是关键字参数，赋值的时候是以键值对的方式，参数可以是任意多对在定义函数的时候</p>
<p>不确定会有多少参数会传入时，就可以使用两个参数</p>
<h2 id="带参数的装饰器">78 带参数的装饰器?</h2>
<p>带定长参数的装饰器</p>
<pre class="python"><code>def new_func(func):
    def wrappedfun(username, passwd):
        if username == &#39;root&#39; and passwd == &#39;123456789&#39;:
            print(&#39;通过认证&#39;)
            print(&#39;开始执行附加功能&#39;)
            return func()
           else:
            print(&#39;用户名或密码错误&#39;)
            return
    return wrappedfun

@new_func
def origin():
    print(&#39;开始执行函数&#39;)
origin(&#39;root&#39;,&#39;123456789&#39;)</code></pre>
<p>带不定长参数的装饰器</p>
<pre class="python"><code>def new_func(func):
    def wrappedfun(*parts):
        if parts:
            counts = len(parts)
            print(&#39;本系统包含 &#39;, end=&#39;&#39;)
            for part in parts:
                print(part, &#39; &#39;,end=&#39;&#39;)
            print(&#39;等&#39;, counts, &#39;部分&#39;)
            return func()
        else:
            print(&#39;用户名或密码错误&#39;)
            return func()
   return wrappedfun</code></pre>
<h2 id="为什么函数名字可以当做参数用">79 为什么函数名字可以当做参数用?</h2>
<p>Python中一切皆对象，函数名是函数在内存中的空间，也是一个对象</p>
<h2 id="python中pass语句的作用是什么">80 Python中pass语句的作用是什么？</h2>
<p>在编写代码时只写框架思路，具体实现还未编写就可以用pass进行占位，是程序不报错，不会进行任何操作。</p>
<h2 id="有这样一段代码print-c会输出什么为什么">81 有这样一段代码，print c会输出什么，为什么？</h2>
<pre class="python"><code>a = 10
b = 20
c = [a]
a = 15</code></pre>
<p>答：10对于字符串，数字，传递是相应的值</p>
<h2 id="交换两个变量的值">82 交换两个变量的值？</h2>
<pre class="python"><code>a, b = b, a</code></pre>
<h2 id="map函数和reduce函数">83 map函数和reduce函数？</h2>
<pre class="python"><code>map(lambda x: x * x, [1, 2, 3, 4])   # 使用 lambda
# [1, 4, 9, 16]
reduce(lambda x, y: x * y, [1, 2, 3, 4])  # 相当于 ((1 * 2) * 3) * 4
# 24</code></pre>
<h2 id="回调函数如何通信的">84 回调函数，如何通信的?</h2>
<p>回调函数是把函数的指针(地址)作为参数传递给另一个函数，将整个函数当作一个对象，赋值给调用的函数。</p>
<h2 id="python主要的内置数据类型都有哪些print-dir-a-的输出">85 Python主要的内置数据类型都有哪些？print dir( ‘a ’) 的输出？</h2>
<p>内建类型：布尔类型，数字，字符串，列表，元组，字典，集合</p>
<p>输出字符串'a'的内建方法</p>
<h2 id="maplambda-xxxy-for-y-in-range3的输出">86 map(lambda x:xx，[y for y in range(3)])的输出？</h2>
<pre class="python"><code>[0, 1, 4]</code></pre>
<h2 id="hasattr-getattr-setattr-函数使用详解">87 hasattr() getattr() setattr() 函数使用详解？</h2>
<p>hasattr(object,name)函数:</p>
<p>判断一个对象里面是否有name属性或者name方法，返回bool值，有name属性（方法）返回True，否则返回False。</p>
<pre class="python"><code>class function_demo(object):
    name = &#39;demo&#39;
    def run(self):
        return &quot;hello function&quot;
functiondemo = function_demo()
res = hasattr(functiondemo, &quot;name&quot;) # 判断对象是否有name属性，True
res = hasattr(functiondemo, &quot;run&quot;) # 判断对象是否有run方法，True
res = hasattr(functiondemo, &quot;age&quot;) # 判断对象是否有age属性，False
print(res)</code></pre>
<p>getattr(object, name[,default])函数：</p>
<p>获取对象object的属性或者方法，如果存在则打印出来，如果不存在，打印默认值，默认值可选。注意：如果返回的是对象的方法，则打印结果是：方法的内存地址，如果需要运行这个方法，可以在后面添加括号().</p>
<pre class="python"><code>functiondemo = function_demo()
getattr(functiondemo, &quot;name&quot;)# 获取name属性，存在就打印出来 --- demo
getattr(functiondemo, &quot;run&quot;) # 获取run 方法，存在打印出方法的内存地址
getattr(functiondemo, &quot;age&quot;) # 获取不存在的属性，报错
getattr(functiondemo, &quot;age&quot;, 18)# 获取不存在的属性，返回一个默认值</code></pre>
<p>setattr(object, name, values)函数：</p>
<p>给对象的属性赋值，若属性不存在，先创建再赋值</p>
<pre class="python"><code>class function_demo(object):
    name = &quot;demo&quot;
    def run(self):
        return &quot;hello function&quot;
functiondemo = function_demo()
res = hasattr(functiondemo, &quot;age&quot;) # 判断age属性是否存在，False
print(res)
setattr(functiondemo, &quot;age&quot;, 18) # 对age属性进行赋值，无返回值
res1 = hasattr(functiondemo, &quot;age&quot;) # 再次判断属性是否存在，True</code></pre>
<p>综合使用</p>
<pre class="python"><code>class function_demo(object):
    name = &quot;demo&quot;
    def run(self):
        return &quot;hello function&quot;
functiondemo = function_demo()
res = hasattr(functiondemo, &quot;addr&quot;) # 先判断是否存在
if res:
    addr = getattr(functiondemo, &quot;addr&quot;)
    print(addr)
else:
    addr = getattr(functiondemo, &quot;addr&quot;, setattr(functiondemo, &quot;addr&quot;, &quot;北京首都&quot;))
    print(addr)</code></pre>
<h2 id="一句话解决阶乘函数">88 一句话解决阶乘函数？</h2>
<pre class="python"><code>reduce(lambda x,y : x*y,range(1,n+1))</code></pre>
<h2 id="对设计模式的理解简述你了解的设计模式">89 对设计模式的理解，简述你了解的设计模式？</h2>
<p>设计模式是经过总结，优化的，对我们经常会碰到的一些编程问题的可重用解决方案。一个设计模式并不像一个类或一个库那样能够直接作用于我们的代码，反之，设计模式更为高级，它是一种必须在特定情形下实现的一种方法模板。<br />
常见的是工厂模式和单例模式</p>
<h2 id="请手写一个单例">90 请手写一个单例</h2>
<pre class="python"><code>#python2
class A(object):
    __instance = None
    def __new__(cls,*args,**kwargs):
        if cls.__instance is None:
            cls.__instance = objecet.__new__(cls)
            return cls.__instance
        else:
            return cls.__instance</code></pre>
<h2 id="单例模式的应用场景有那些">91 单例模式的应用场景有那些？</h2>
<p>单例模式应用的场景一般发现在以下条件下：<br />
资源共享的情况下，避免由于资源操作时导致的性能或损耗等，如日志文件，应用配置。<br />
控制资源的情况下，方便资源之间的互相通信。如线程池等，1,网站的计数器 2,应用配置 3.多线程池 4数据库配置 数据库连接池 5.应用程序的日志应用…</p>
<h2 id="用一行代码生成149162536496481100-1">92 用一行代码生成[1,4,9,16,25,36,49,64,81,100]</h2>
<pre class="python"><code>print([x*x for x in range(1, 11)])</code></pre>
<h2 id="对装饰器的理解并写出一个计时器记录方法执行性能的装饰器">93 对装饰器的理解，并写出一个计时器记录方法执行性能的装饰器？</h2>
<p>装饰器本质上是一个callable object ，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。</p>
<pre class="python"><code>import time
from functools import wraps

def timeit(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.clock()
        ret = func(*args, **kwargs)
        end = time.clock()
        print(&#39;used:&#39;,end-start)
        return ret

    return wrapper
@timeit
def foo():
    print(&#39;in foo()&#39;foo())</code></pre>
<h2 id="解释以下什么是闭包">94 解释以下什么是闭包？</h2>
<p>在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。</p>
<h2 id="函数装饰器有什么作用">95 函数装饰器有什么作用？</h2>
<p>装饰器本质上是一个callable object，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。装饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。比如：插入日志，性能测试，事务处理，缓存。权限的校验等场景，有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。<br />
详细参考：https://manjusaka.itscoder.com/2018/02/23/something-about-decorator/</p>
<h2 id="生成器迭代器的区别">96 生成器，迭代器的区别？</h2>
<p>迭代器是遵循迭代协议的对象。用户可以使用 iter() 以从任何序列得到迭代器（如 list, tuple, dictionary, set 等）。另一个方法则是创建一个另一种形式的迭代器 —— generator 。要获取下一个元素，则使用成员函数 next()（Python 2）或函数 next() function （Python 3） 。当没有元素时，则引发 StopIteration 此例外。若要实现自己的迭代器，则只要实现 next()（Python 2）或 <code>__next__</code>()（ Python 3）</p>
<p>生成器（Generator），只是在需要返回数据的时候使用yield语句。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）</p>
<p>区别：生成器能做到迭代器能做的所有事，而且因为自动创建iter()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。</p>
<h2 id="x是什么类型">97 X是什么类型?</h2>
<p>X= (i for i in range(10))<br />
X是 generator类型</p>
<h2 id="请用一行代码-实现将1-n-的整数列表以3为单位分组">98 请用一行代码 实现将1-N 的整数列表以3为单位分组</h2>
<pre class="python"><code>N =100
print ([[x for x in range(1,100)] [i:i+3] for i in range(0,100,3)])</code></pre>
<h2 id="python中yield的用法">99 Python中yield的用法?</h2>
<p>yield就是保存当前程序执行状态。你用for循环的时候，每次取一个元素的时候就会计算一次。用yield的函数叫generator,和iterator一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间，generator每次计算需要上一次计算结果，所以用yield,否则一return，上次计算结果就没了</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>