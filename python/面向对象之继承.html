<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修面向对象之继承' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>面向对象之继承</center></div><div class='banquan'>原文出处:本文由博客园博主虚xu提供。<br/>
原文连接:https://www.cnblogs.com/zrxu/p/11609451.html</div><br>
    <p>什么是继承？<br />继承指的是类与类之间的关系，是一种什么&ldquo;是&rdquo;什么的关系，继承的功能之一就是用来解决代码重用问题<br />继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可以成为基类或超类，新建的类称为派生类或子类<br /><br />python中类的继承分为:单继承和多继承<br />class ParentClass1: #定义父类<br />&nbsp;&nbsp;&nbsp; pass<br /><br />class ParentClass2: #定义父类<br />&nbsp;&nbsp;&nbsp; pass<br /><br />class SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass<br />&nbsp;&nbsp;&nbsp; pass<br /><br />class SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类<br />&nbsp;&nbsp;&nbsp; pass<br /><br />查看继承:<br />SubClass1.__bases__<br /><br />经典类和新式类:<br />Python2：类分为经典类和新式类<br />经典类:没有继承object类的类<br />新式类:继承object类的类<br />Python3:只有新式类，创建的类若没有指定基类，默认继承object类<br /><br />继承和抽象:<br />抽象:抽取类似或者比较像的部分<br />抽象分为两个部分:<br />1、将对象的相似部分抽取成类<br />2、将类与类相似的部分抽取成父类<br />继承：是基于抽象的结果，通过编程语言去实现它，肯定是先经历抽象这个过程，才能通过继承的方式去表达出抽象的结构。<br /><br />继承如何实现代码重用:<br />在开发程序的过程中，如果我们定义了一个类A，然后又想新建立另外一个类B，但是类B的大部分内容与类A的相同时,我们不可能从头开始写一个类B，这就用到了类的继承的概念。<br />通过继承的方式新建类B，让B继承A，B会&lsquo;遗传&rsquo;A的所有属性(数据属性和函数属性)，实现代码重用<br /><br />派生:<br />子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Hero:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name, aggresivity, life_value):
        self.Aggresivity </span>=<span style="color: #000000;"> aggresivity
        self.Name </span>=<span style="color: #000000;"> name
        self.Life_value </span>=<span style="color: #000000;"> life_value

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> attack(self, obj):
        obj.Life_value </span>-=<span style="color: #000000;"> self.Aggresivity
        </span><span style="color: #0000ff;">if</span> obj.Life_value &lt;=<span style="color: #000000;"> 0:
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 死亡</span><span style="color: #800000;">'</span> %<span style="color: #000000;">obj.Name)
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> True
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">%s被攻击, 生命值为:%s</span><span style="color: #800000;">"</span> %<span style="color: #000000;">(obj.Name, obj.Life_value))
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> False

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Gailun(Hero):
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> attack(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">我帅的一B!!!</span><span style="color: #800000;">"</span><span style="color: #000000;">)

g1 </span>= Gailun(<span style="color: #800000;">'</span><span style="color: #800000;">盖伦</span><span style="color: #800000;">'</span>, 70, 100<span style="color: #000000;">)
g1.attack()
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 打印结果:我帅的一B!!!</span></pre>
</div>
<p><br /><br />继承的实现原理:<br />python到底是如何实现继承的，对于你定义的每一个类，python会计算出一个方法解析顺序(MRO)列表，这个MRO列表就是一个简单的所有基类的线性顺序列表。<br />为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:<br /><br />&nbsp;&nbsp;&nbsp; 子类会先于父类被检查<br />&nbsp;&nbsp;&nbsp; 多个父类会根据它们在列表中的顺序被检查<br />&nbsp;&nbsp;&nbsp; 如果对下一个类存在两个合法的选择,选择第一个父类<br /><br />Python中子类可以同时继承多个父类，如果继承了多个父类，那么属性的查找方式有两种，分别是：深度优先和广度优先<br /><br />经典类的查找方式为深度优先、新式类的查找方式为广度优先<br />深度优先:一条路走到底后，在查找另一个父类<br />A(B,C,D) ---&gt; B(E) ---&gt;E(G)---&gt;G---&gt;C(F)---&gt;F(G)---&gt;D(G)<br />广度优先<br />A(B,C,D) ---&gt; B(E) ---&gt;E(G)---&gt;C(F)---&gt;F(G)---&gt;D(G)---&gt;G<br />示例:(Python3中)</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> A(object):
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> test(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">from A</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> B(A):
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> test(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">from B</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> C(A):
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> test(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">from C</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> D(B):
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> test(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">from D</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> E(C):
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> test(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">from E</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> F(D,E):
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> def test(self):</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">     print('from F')</span>
    <span style="color: #0000ff;">pass</span><span style="color: #000000;">

f </span>=<span style="color: #000000;"> F()
f.text()
</span><span style="color: #0000ff;">print</span>(F.<span style="color: #800080;">__mro__</span>) <span style="color: #008000;">#</span><span style="color: #008000;">只有新式才有这个属性可以查看线性列表，经典类没有这个属性</span>
<span style="color: #000000;">
查找方式
F</span>---&gt;D---&gt;B---&gt;E---&gt;C---&gt;A</pre>
</div>
<p><br /><br />在子类中调用父类的方法:<br />1、指名道姓 不依赖继承关系<br />2、super() 依赖继承关系<br />一、指名道姓:</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Hero:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name, aggresivity, life_value):
        self.Aggresivity </span>=<span style="color: #000000;"> aggresivity
        self.Name </span>=<span style="color: #000000;"> name
        self.Life_value </span>=<span style="color: #000000;"> life_value

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> attack(self, obj):
        obj.Life_value </span>-=<span style="color: #000000;"> self.Aggresivity
        </span><span style="color: #0000ff;">if</span> obj.Life_value &lt;=<span style="color: #000000;"> 0:
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 死亡</span><span style="color: #800000;">'</span> %<span style="color: #000000;">obj.Name)
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> True
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">%s被攻击, 生命值为:%s</span><span style="color: #800000;">"</span> %<span style="color: #000000;">(obj.Name, obj.Life_value))
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> False

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Gailun(Hero):
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> attack(self, this_obj):
        Hero.attack(self, this_obj)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">我帅的一B!!!</span><span style="color: #800000;">"</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Ruiwen(Hero):
    </span><span style="color: #0000ff;">pass</span><span style="color: #000000;">


g1 </span>= Gailun(<span style="color: #800000;">"</span><span style="color: #800000;">盖伦</span><span style="color: #800000;">"</span>, 30, 100<span style="color: #000000;">)
r1 </span>= Ruiwen(<span style="color: #800000;">"</span><span style="color: #800000;">锐雯</span><span style="color: #800000;">"</span>， 20, 100<span style="color: #000000;">)

g1.attack(r1)

</span><span style="color: #008000;">#</span><span style="color: #008000;"> 锐雯被攻击, 生命值为:70</span><span style="color: #008000;">
#</span><span style="color: #008000;"> 我帅的一B!!!</span></pre>
</div>
<p>父类的属性中有多少个参数，在子类调用的时候就要传递多少个参数<br /><br />二、super():</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Hero:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name, aggresivity, life_value):
        self.Aggresivity </span>=<span style="color: #000000;"> aggresivity
        self.Name </span>=<span style="color: #000000;"> name
        self.Life_value </span>=<span style="color: #000000;"> life_value

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> attack(self, obj):
        obj.Life_value </span>-=<span style="color: #000000;"> self.Aggresivity
        </span><span style="color: #0000ff;">if</span> obj.Life_value &lt;=<span style="color: #000000;"> 0:
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 死亡</span><span style="color: #800000;">'</span> %<span style="color: #000000;">obj.Name)
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> True
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">%s被攻击, 生命值为:%s</span><span style="color: #800000;">"</span> %<span style="color: #000000;">(obj.Name, obj.Life_value))
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> False

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Gailun(Hero):


    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self, name, aggresivity, life_value, weapon):
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">(name, aggresivity, life_value)
        self.Weapon </span>=<span style="color: #000000;"> weapon


    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> attack(self, this_obj):
        Hero.attack(self, this_obj)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">我帅的一B!!!</span><span style="color: #800000;">"</span><span style="color: #000000;">)


g1 </span>= Gailun(<span style="color: #800000;">"</span><span style="color: #800000;">盖伦</span><span style="color: #800000;">"</span>, 30, 100, <span style="color: #800000;">'</span><span style="color: #800000;">刀</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span>(g1.<span style="color: #800080;">__dict__</span><span style="color: #000000;">)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> {'Aggresivity': 30, 'Name': '盖伦', 'Life_value': 100, 'Weapon': '刀'}</span></pre>
</div>
<p>在调用父类__init__方法时，super()可以不用传递子类名和self。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> A:
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f1(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">from A</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        super().f1()


</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> B:
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f1(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">from B</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> C(A,B):
    </span><span style="color: #0000ff;">pass</span>


<span style="color: #008000;">#</span><span style="color: #008000;"> print(C.mro())</span><span style="color: #008000;">
#</span><span style="color: #008000;"> [&lt;class '__main__.C'&gt;,</span><span style="color: #008000;">
#</span><span style="color: #008000;"> &lt;class '__main__.A'&gt;,</span><span style="color: #008000;">
#</span><span style="color: #008000;"> &lt;class '__main__.B'&gt;,</span><span style="color: #008000;">
#</span><span style="color: #008000;"> &lt;class 'object'&gt;]</span>
<span style="color: #000000;">

c</span>=<span style="color: #000000;">C()
c.f1()
</span><span style="color: #008000;">#</span><span style="color: #008000;"> from A</span><span style="color: #008000;">
#</span><span style="color: #008000;"> from B</span></pre>
</div>
<p>super()依照的是mro列表的</p>
<p>&nbsp;</p>
<p>组合:</p>
<p>&nbsp;组合的方式<br />用组合的方式建立了类与组合的类之间的关系，它是一种&lsquo;有&rsquo;的关系,比如教授有生日，教授教python和linux课程，教授有学生stu1、stu2、stu3</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> People:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,name,age,sex):
        self.name</span>=<span style="color: #000000;">name
        self.age</span>=<span style="color: #000000;">age
        self.sex</span>=<span style="color: #000000;">sex

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Course:
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,name,period,price):
        self.name</span>=<span style="color: #000000;">name
        self.period</span>=<span style="color: #000000;">period
        self.price</span>=<span style="color: #000000;">price
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> tell_info(self):
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">&lt;%s %s %s&gt;</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(self.name,self.period,self.price))

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Teacher(People):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,name,age,sex,job_title):
        People.</span><span style="color: #800080;">__init__</span><span style="color: #000000;">(self,name,age,sex)
        self.job_title</span>=<span style="color: #000000;">job_title
        self.course</span>=<span style="color: #000000;">[]
        self.students</span>=<span style="color: #000000;">[]


</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Student(People):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,name,age,sex):
        People.</span><span style="color: #800080;">__init__</span><span style="color: #000000;">(self,name,age,sex)
        self.course</span>=<span style="color: #000000;">[]


egon</span>=Teacher(<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span>,18,<span style="color: #800000;">'</span><span style="color: #800000;">male</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">沙河霸道金牌讲师</span><span style="color: #800000;">'</span><span style="color: #000000;">)
s1</span>=Student(<span style="color: #800000;">'</span><span style="color: #800000;">牛榴弹</span><span style="color: #800000;">'</span>,18,<span style="color: #800000;">'</span><span style="color: #800000;">female</span><span style="color: #800000;">'</span><span style="color: #000000;">)

python</span>=Course(<span style="color: #800000;">'</span><span style="color: #800000;">python</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">3mons</span><span style="color: #800000;">'</span>,3000.0<span style="color: #000000;">)
linux</span>=Course(<span style="color: #800000;">'</span><span style="color: #800000;">python</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">3mons</span><span style="color: #800000;">'</span>,3000.0<span style="color: #000000;">)

</span><span style="color: #008000;">#</span><span style="color: #008000;">为老师egon和学生s1添加课程</span>
<span style="color: #000000;">egon.course.append(python)
egon.course.append(linux)
s1.course.append(python)

</span><span style="color: #008000;">#</span><span style="color: #008000;">为老师egon添加学生s1</span>
egon.students.append(s1)</pre>
</div>
<p>for obj in egon.course:<br />&nbsp;&nbsp;&nbsp; obj.tell_info()<br /><br />当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好。</p>
<p>&nbsp;</p>
<p>抽象类:</p>
<p>1 什么是抽象类<br /><br />与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化<br /><br />2 为什么要有抽象类<br /><br />如果说类是从一堆对象中抽取相同的内容而来的，那么抽象类就是从一堆类中抽取相同的内容而来的，内容包括数据属性和函数属性。<br /><br />　 比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西。<br /><br />从设计角度去看，如果类是从现实对象抽象而来的，那么抽象类就是基于类抽象而来的。<br /><br />　 从实现角度来看，抽象类与普通类的不同之处在于：抽象类中只能有抽象方法（没有实现功能），该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span><span style="color: #000000;"> abc
</span><span style="color: #0000ff;">class</span> Animals(metaclass =<span style="color: #000000;"> ABCMeta):

    @abc.abstractmethod    </span><span style="color: #008000;">#</span><span style="color: #008000;">定义抽象方法，无需实现功能</span>
    <span style="color: #0000ff;">def</span><span style="color: #000000;"> walk(self):
        </span><span style="color: #0000ff;">pass</span><span style="color: #000000;">
    
    @abc.abstactmethod    </span><span style="color: #008000;">#</span><span style="color: #008000;">定义抽象方法，无需实现功能</span>
    <span style="color: #0000ff;">def</span><span style="color: #000000;"> sleep(self):
        </span><span style="color: #0000ff;">pass</span>

<span style="color: #0000ff;">class</span><span style="color: #000000;"> People(Animals):
    
    </span><span style="color: #0000ff;">def</span> walk(self)   <span style="color: #008000;">#</span><span style="color: #008000;"> 必须定义此方法</span>
        <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">is walking</span><span style="color: #800000;">"</span><span style="color: #000000;">)
 
    </span><span style="color: #0000ff;">def</span> sleep(self)  <span style="color: #008000;">#</span><span style="color: #008000;"> 必须定义此方法</span>
        <span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">is sleeping</span><span style="color: #800000;">"</span>)</pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>